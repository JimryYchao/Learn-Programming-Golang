## Go 组成元素

---
### 词汇元素

#### 标记、注释、语句终止符、标识符

> *Tokens*

标记（*Tokens* ）构成了 Go 的词汇表：标识符、关键字、运算符和标点符号。由空格（U+0020）、水平制表符（U+0009）、回车符（U+000D） 和换行符（U+000A） 组成的空格将被忽略，除非它分隔了原本将组合成单个标记的标记。此外，换行符或文件末尾可能会触发分号的插入。在将输入分解为标记时，下一个标记是构成有效标记的最长字符序列。

> *注释*

```go
//  Line comment
/*
    General comments
*/
```

> *语句终止符*

许多形式语法中使用 `;` 作为语句终止符，Go 可以使用以下两个规则省略部分分号：
- 当输入被分解为标记时，如果该标记是：
  - 一个标识符；
  - 一个整数、浮点数、虚数、字符或字符串的文本；
  - `break`、`continue`、`return`、`fallthrough` 关键字之一；
  - `++`、`--`、`)`、`]`、`}` 运算符和标点符之一。
- 占据一行的复杂语句，以 `)` 或 `}` 结尾。

> *标识符*

标识符为程序实体命名，例如变量和类型。标识符是一个或多个字母和数字的序列。标识符中的第一个字符必须是字母。

```go
a
_Identifier
Identifier
Identifier123
αβ
```

> *预声明标识符*

```go
Types:
	any bool byte comparable
	complex64 complex128 error float32 float64
	int int8 int16 int32 int64 rune string
	uint uint8 uint16 uint32 uint64 uintptr

Constants:
	true false iota

Zero value:
	nil

Functions:
	append cap clear close complex copy delete imag len
	make max min new panic print println real recover
```

>---
#### 关键字

> *标准 Go 关键字*

| Keyword       | Description                                     |
| :------------ | :---------------------------------------------- |
| `break`       | 跳出当前循环或分支                              |
| `case`        | `switch`、`select` 语句的 `case` 分支           |
| `chan`        | 通道类型声明                                    |
| `const`       | 常量声明                                        |
| `continue`    | 跳转至当前循环体末尾                            |
| `default`     | `switch`、`select` 语句的 `default` 分支        |
| `defer`       | 延时函数调用                                    |
| `else`        | `if` 语句的否定分支                             |
| `fallthrough` | `switch` 语句直落语句                           |
| `for`         | `for` 迭代语句                                  |
| `func`        | 函数类型声明                                    |
| `go`          | 开启一个并发线程或 *goroutine*                  |
| `goto`        | 无条件跳转语句                                  |
| `if`          | `if` 条件语句                                   |
| `import`      | 包导入                                          |
| `interface`   | 接口类型声明                                    |
| `map`         | 映射类型声明                                    |
| `package`     | 包声明                                          |
| `range`       | `for` 语句范围表达式                            |
| `return`      | 函数返回语句                                    |
| `select`      | 选择语句                                        |
| `struct`      | 结构体声明                                      |
| `switch`      | `switch` 条件语句                               |
| `type`        | 类型定义或别名声明，*TypeSwitch* 的 `id.(type)` |
| `var`         | 变量声明                                        |

> *内置保留标识符*

| Identifier   | Description                                                 |
| :----------- | :---------------------------------------------------------- |
| `any`        | 空接口 `interface{}` 的别名，它代表所有（非接口）类型的集合 |
| `bool`       | 布尔类型                                                    |
| `byte`       | 字节类型                                                    |
| `comparable` | 可比较接口                                                  |
| `complex64`  | `float32` 复数类型                                          |
| `complex128` | `float64` 复数类型                                          |
| `error`      | 错误条件                                                    |
| `float32`    | 单精度浮点类型                                              |
| `float64`    | 双精度浮点类型                                              |
| `int`        | 32 或 64 位有符号整数                                       |
| `int8`       | 8 位有符号整数                                              |
| `int16`      | 16 位有符号整数                                             |
| `int32`      | 32 位有符号整数                                             |
| `int64`      | 64 位有符号整数                                             |
| `rune`       | UTF-8 编码的 Unicode 码位的数值表示                         |
| `string`     | 字符串类型                                                  |
| `uint`       | 32 或 64 位无符号整数                                       |
| `uint8`      | 8 位无符号整数                                              |
| `uint16`     | 16 位无符号整数                                             |
| `uint32`     | 32 位无符号整数                                             |
| `uint64`     | 64 位无符号整数                                             |
| `uintptr`    | 足以存储指针值的无符号整数类型                              |
| `true`       | 布尔真值                                                    |
| `false`      | 布尔假值                                                    |
| `iota`       | 特殊常量值，连续的无类型整数常量，只能用于常量赋值          |
| `nil`        | 空值                                                        |


>----
#### 运算符与标点符号

```go
+    &     +=    &=     &&    ==    !=    (    )
-    |     -=    |=     ||    <     <=    [    ]
*    ^     *=    ^=     <-    >     >=    {    }
/    <<    /=    <<=    ++    =     :=    ,    ;
%    >>    %=    >>=    --    !     ...   .    :
     &^          &^=          ~
```

>---
#### 文本

##### 整数文本

整数文本是表示整数常量的数字序列。`0b`、`0B` 用于二进制文本前缀；`0` 或 `0o`、`0O` 用于八进制；`0x`、`0X` 用于十六进制。`_` 用于数字分隔符。

```go
// decimal
42
4_2
// binary
0b1010
0B_0101
// octal
0600
0_600
0o600
0O600       // second character is capital letter 'O'
// hexadecimal
0xBadFace
0xBad_Face
0x_67_7a_2f_cc_40_c6
// separator
170141183460469231731687303715884105727
170_141183_460469_231731_687303_715884_105727

// Error integer literals
_42         // an identifier, not an integer literal
42_         // invalid: _ must separate successive digits
4__2        // invalid: only one _ at a time
0_xBadFace  // invalid: _ must separate successive digits
```

<br>

##### 浮点文本
 
浮点文本是浮点常量的十进制或十六进制表示形式。

十进制浮点文本由整数部分（十进制数字）、小数点、小数部分（十进制数字）和指数部分（`e` 或 `E` 后跟可选符号和十进制数字）组成。可以省略整数部分或小数部分之一；可以省略小数点或指数部分之一。指数值 *exp* 将尾数（整数和小数部分）缩放 $10^{exp}$。

十六进制浮点文本由 `0x` or `0X` 前缀、整数部分（十六进制数字）、小数点、小数部分（十六进制数字）和指数部分（`p` 或 `P` 后跟可选符号和十进制数字）组成。可以省略整数部分或小数部分之一；小数点也可以省略，但指数部分是必需的。（此语法与 IEEE 754-2008 §5.12.3. 中给出的语法匹配。）指数值 *exp* 将尾数（整数和小数部分）缩放 $2 ^{exp}$。

数字分隔符 `_` 可以出现在前缀 `0x` or `0X` 之后或连续数字之间。

```go
// decimal
0.
72.40
072.40       // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
1_5.         // == 15.0
0.15e+0_2    // == 15.0

// hexadecimal
0x1p-2       // == 0.25
0x2.p10      // == 2048.0
0x1.Fp+0     // == 1.9375
0X.8p-0      // == 0.5
0X_1FFFP-16  // == 0.1249847412109375
0x15e-2      // == 0x15e - 2 (integer subtraction)

// Error floating-point literals
0x.p1        // invalid: mantissa has no digits
1p-2         // invalid: p exponent requires hexadecimal mantissa
0x1.5e-2     // invalid: hexadecimal mantissa requires p exponent
1_.5         // invalid: _ must separate successive digits
1._5         // invalid: _ must separate successive digits
1.5_e1       // invalid: _ must separate successive digits
1.5e_1       // invalid: _ must separate successive digits
1.5e1_       // invalid: _ must separate successive digits
```

<br>

##### 虚数文本

虚数文本表示复数常量的虚数部分。它由一个整数或浮点字面量组成，后跟小写字母 `i`。虚数文本的值是相应整数或浮点文本的值乘以虚数单位 `i`。 

为了向后兼容，完全由十进制数字（可能还有下划线）组成的虚数文本的整数部分被视为十进制整数，即使它以前导 0 开头。

```go
0i
0123i         // == 123i for backward-compatibility
0o123i        // == 0o123 * 1i == 83i
0xabci        // == 0xabc * 1i == 2748i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i
0x1p-2i       // == 0x1p-2 * 1i == 0.25i
```

<br>

##### 字符文本

字符文本表示一个字符常量，一个标识 Unicode 码位的整数值。Go 源文本是以 UTF-8 编码的 Unicode 字符，因此多个 UTF-8 编码的字节可以表示单个整数值。文本 `'a'` 包含一个表示文本 a Unicode U+0061 值 0x61 的单个字节，而 `'ä'` 包含两个字节（0xc3 0xa4）表示文本 a-dieresis，U+00E4，值 0xe4。

几个个反斜杠转义允许将任意值编码为 ASCII 文本。有四种方法可以将整数值表示为数值常量，在每种情况下，文本的值都是由相应基数中的数字表示的值：
- `\x` 后跟正好两个十六进制数字；
- `\u` 后跟正好四个十六进制数字；
- `\U` 后面正好是八个十六进制数字；
- 一个反斜杠 `\` 后跟正好三个八进制数字。

> 转义字符

```go
'\a'   // U+0007 alert or bell
'\b'   // U+0008 backspace
'\f'   // U+000C form feed
'\n'   // U+000A line feed or newline
'\r'   // U+000D carriage return
'\t'   // U+0009 horizontal tab
'\v'   // U+000B vertical tab
'\\'   // U+005C backslash
'\''   // U+0027 single quote  (valid escape only within rune literals)
'\"'   // U+0022 double quote  (valid escape only within string literals)
```

字符文本中的反斜杠后随无法识别的字符是非法的。

```go
'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'
'\''         // rune literal containing single quote character
'aa'         // illegal: too many characters
'\k'         // illegal: k is not recognized after a backslash
'\xa'        // illegal: too few hexadecimal digits
'\0'         // illegal: too few octal digits
'\400'       // illegal: octal value over 255
'\uDFFF'     // illegal: surrogate half
'\U00110000' // illegal: invalid Unicode code point
```

<br>

##### 字符串文本

字符串文本表示通过连接字符序列获得的字符串常量。有两种形式：原始字符串和解释字符串。

原始字符串是反引号之间的字符序列，如 `` `foo` ``。原始字符串中除了反引号之外，任何字符都可以出现。原始字符串文本的值是由反引号之间未解释的（隐式 UTF-8 编码）字符组成的字符串；特别是，反斜杠没有特殊含义，字符串可能包含换行符。原始字符串文本中的回车符 （`'\r'`） 将从原始字符串值中丢弃。

解释字符串是双引号之间的字符序列，如 `"bar"` 。在引号中，除了换行符和未转义的双引号外，可以出现任何字符。引号之间的文本构成了文本的值，反斜杠转义被解释为字符文本的文本（除了 `\'` 这是非法的和 `\"` 合法的）。三位八进制（`\ nnn`）和两位十六进制（ `\x nn`）转义表示结果字符串的单个字节；所有其他转义都表示单个字符的（可能是多字节）UTF-8 编码。因此，在字符串文本中 `\377`，表示 `\xFF` 值 `0xFF =255` 的单个字节，而 `ÿ`， `\u00FF`、`\U000000FF` 和 `\xc3\xbf` 表示字符 U+00FF 的 UTF-8 编码的两个字节 0xc3 0xbf。

```go
// 原始字符串
`abc`                // same as "abc"
`\n
\n`                  // same as "\\n\n\\n"

// 解释字符串
"\n"
"\""                 // same as `"`
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"

"\uD800"             // illegal: surrogate half
"\U00110000"         // illegal: invalid Unicode code point
```

> 以下表示相同的字符串

```go
"日本語"                                 // UTF-8 input text
`日本語`                                 // UTF-8 input text as a raw literal
"\u65e5\u672c\u8a9e"                     // the explicit Unicode code points
"\U000065e5\U0000672c\U00008a9e"         // the explicit Unicode code points
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"   // the explicit UTF-8 bytes
```

---
### 声明与作用域

声明将非空标识符绑定到常量、类型、类型参数、变量、函数、标签或包。程序中的每个标识符都必须声明。标识符不能在同一个块中声明两次，也不能在文件块和包块中同时声明标识符。

空标识符可以像声明中的任何其他标识符一样使用，但它不引入绑定，因此不被声明。在 `package` 块中，标识符 `init` 只能用于 `init` 函数声明，并且与空标识符（`_`）一样，它不会引入新的绑定。

```ANTLR
Declaration   = ConstDecl | TypeDecl | VarDecl 
TopLevelDecl  = Declaration | FunctionDecl | MethodDecl 
```

声明的标识符的作用域是源文本的范围，其中标识符表示指定的常量、类型、变量、函数、标签或包。

Go 语言使用块来限定词法作用域：
- 预先声明的标识符的作用域是 *universe* 块。
- 标识符的作用域是包块，它表示在顶层（任何函数之外）声明的常量、类型、变量或函数（但不是方法）。
- 导入包的包名的作用域是包含导入声明的文件的文件块。
- 表示方法接收器、函数参数或结果变量的标识符的作用域是函数体。
- 表示函数的类型参数或由方法接收器声明的标识符的作用域，开始于函数名之后，结束于函数体的末尾。
- 表示类型的类型参数的标识符的作用域从类型名称之后开始，到 *TypeSpec* 的末尾结束。
- 在函数内部声明的常量或变量标识符的作用域开始于 *ConstSpec* 或 *VarSpec* 的末尾（短变量声明的 *ShortVarDecl*），结束于最里面的包含块的末尾。
- 在函数内部声明的类型标识符的作用域从 *TypeSpec* 中的标识符开始，到最里面的包含块的末尾结束。

在块中声明的标识符可以在内部块中重新声明。当内部声明的标识符在作用域中时，它表示由内部声明声明的实体。

*package* 子句不是声明；包名称不出现在任何范围中。它的目的是标识属于同一个包的文件，并为导入声明指定默认的包名。

>---
#### 标签作用域

标签由带标签的语句声明，并在 “`break`”、“`continue`” 和 “`goto`” 语句中使用。定义一个从未使用过的标签是非法的。与其他标识符相比，标签不是块范围的，并且不与不是标签的标识符冲突。标签的作用域是声明它的函数体，不包括任何嵌套函数体。

>---

#### 空标识符

空标识符由下划线字符 `_` 表示。它用作匿名占位符而不是常规（非空）标识符，并且在声明、操作数和赋值语句中具有特殊意义。

```go
_ = foo()     // 放弃接收函数或表达式的返回值
```

空标识符可以用任何类型的任何值来赋值或声明，而该值将被无害地丢弃。如果一个赋值需要在左边有多个值，但其中一个值不会被程序使用，那么在赋值的左边有一个空的标识符就可以避免创建一个伪变量，并明确表示该值将被丢弃。

```go
if _, err := os.Stat(path); os.IsNotExist(err) {
    fmt.Printf("%s does not exist\n", path)
}
```

有时候，导入一个包只是为了它的副作用，而没有任何显式的用途。例如，`net/http/pprof` 包在其 `init` 函数调用时，注册提供调试信息的 HTTP 处理程序。它有一个导出的 API，但大多数客户端只需要处理程序注册并通过网页访问数据。若要仅针对其副作用导入包，可以将包重命名为空标识符：

```go
import _ "net/http/pprof"   // 匿名导入
```

如果仅仅是类型检查而不是创建变量，可以使用空标识符来忽略类型断言的值：

```go
// 例如
m, ok = val.(json.Marshaler)
// 仅类型检查 >>> 
if _, ok := val.(json.Marshaler); ok {
    fmt.Printf("value %v of type %T implements json.Marshaler\n", val, val)
}
```

>---
#### 预先声明的标识符

以下标识符在 *universe* 块中隐式声明：

```go
// Types:
	any bool byte comparable
	complex64 complex128 error float32 float64
	int int8 int16 int32 int64 rune string
	uint uint8 uint16 uint32 uint64 uintptr

// Constants:
	true false iota

// Zero value:
	nil

// Functions:
	append cap clear close complex copy delete imag len
	make max min new panic print println real recover
```

>---
#### 导出标识符

可以导出标识符以允许从另一个包访问它。如果存在以下情况，则导出标识符：
- 标识符名称的第一个字符是 Unicode 字符（Unicode 字符类别 Lu，字母大写）；并且
- 标识符在包块中声明（顶级声明），或者它是字段名或方法名。

不导出所有其他标识符。`'_'` 被视为小写字母。

```go
package ExportExample

type ExportType Type
const ExportConstant = ...
func ExportFunc(){ ... }
var _inlineVar ExportType = ...   // 内部静态变量，不导出
```

>---
#### 标识符的唯一性

给定一组标识符，如果一个标识符与集合中的其他标识符不同，则该标识符被称为唯一的。如果两个标识符的拼写不同，或者它们出现在不同的包中并且未导出，则它们是不同的。否则，它们是相同的。

>---
#### 限定标识符

限定标识符是用包名前缀限定的标识符。包名称和标识符都不能为空。

```ANTLR
QualifiedIdent = PackageName "." identifier 
```

限定标识符访问的不同包中的标识符，该包必须被 `import`。标识符必须在该包的包块中导出和声明。

```go
math.Sin // denotes the Sin function in package math
```

---
### 常量与变量

#### 常量

有布尔常量、字符常量、整数常量、浮点常量、复数常量和字符串常量。字符常量、整数常量、浮点常量和复数常量统称为数值常量。

常量值由字符、整数、浮点、虚数或字符串文本、表示常量的标识符、常量表达式、结果为常量的转换或某些内置函数的结果值表示，例如 `min` 或 `max` 应用于常量参数、`unsafe.Sizeof` 应用于某些值或 `cap` 或 `len` 应用于某些表达式。布尔值由预先声明的 `true` 常量 和 `false` 表示。预先声明的标识符 `iota` 表示整数常量。

数值常量表示任意精度的精确值，并且不会溢出。因此，没有常量表示 IEEE-754 负零、无穷大和非数字值。

常量可以是类型化的，也可以是非类型的。文本常量、 `true`、`false` 和 `iota` 某些仅包含非类型化常量操作数的常量表达式是非类型化的。

常量可以通过常量声明或显式转换为指定类型，也可以在变量声明、赋值语句、或者在表达式中用作操作数时隐式指定类型。如果常量值不能表示为相应类型的值，则会产生错误。如果类型是类型参数，则将该常量转换为类型参数的非常量值。

非类型化常量具有默认类型，该类型是在需要类型化值的上下文中将常量隐式转换为的类型，例如，在没有显式指定类型的短变量声明中，例如 `i := 0`。非类型化常量的默认类型分别是 `bool`、`rune`、`int`、`float64`、`complex128` 或 `string`，具体取决于它是布尔常量、字符常量、整数常量、浮点常量、复数常量还是字符串常量。

实现限制：尽管数值常量在语言中具有任意精度，但编译器可以使用精度有限的内部表示形式来实现它们。也就是说，每个实现都必须：
- 表示至少具有 256 位的整数常量。
- 表示浮点常量，包括复数常量的各个部分，尾数至少为 256 位，有符号二进制指数至少为 16 位。
- 如果无法精确表示整数常量，则给出错误。
- 如果由于溢出而无法表示浮点或复常量，则给出错误。
- 如果由于精度限制而无法表示浮点或复常量，则舍入到最接近的可表示常量。

这些要求既适用于文本常量，也适用于计算常量表达式的结果。

<br>

##### const：常量声明

常量声明将标识符列表（常量的名称）绑定到常量表达式列表的值。标识符的数量必须等于表达式的数量，并且左侧的第 n 个标识符绑定到右侧的第 n 个表达式的值。

```ANTLR
ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) 
ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] 

IdentifierList = identifier { "," identifier } 
ExpressionList = Expression { "," Expression } 
```

如果该类型存在，则所有常量都采用指定的类型，并且表达式必须可分配给该类型，该类型不能是类型参数。如果省略类型，则常量采用相应表达式的各个类型。如果表达式值是无类型的常量，则声明的常量保持无类型，常量标识符表示常量值。例如，如果表达式是浮点文本，则常量标识符表示浮点常量，即使文本的小数部分为零。

```go
const Pi float64 = 3.14159265358979323846
const zero = 0.0         // untyped floating-point constant
const (
	size int64 = 1024
	eof        = -1      // untyped integer constant
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo", untyped integer and string constants
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
```

在带括号的 `const` 声明列表中，除了第一个 *ConstSpec* 之外，表达式列表可以从任何地方省略。这样的空列表等价于前面第一个非空表达式列表及其类型（如果有的话）的文本替换。因此，省略表达式列表等同于重复前面的列表。标识符的数目必须等于前面列表中表达式的数目。与 *`iota`* 常量生成器一起，该机制允许对顺序值进行轻量级声明：

```go
const (
	Sunday = iota	
	Monday			
	Tuesday			
	Wednesday		
	Thursday		
	Friday			
	Partyday		
	numberOfDays    //  this constant is not exported
)
```

<br>

##### iota

在常量声明中，预先声明的标识符 `iota` 表示连续的无类型整数常量。它的值是常量声明中相应的 *ConstSpec* 的索引，从零开始。它可以用来构造一组相关的常量：

```go
const (
	c0 = iota  // c0 == 0
	c1 = iota  // c1 == 1
	c2 = iota  // c2 == 2
)

const (
	a = 1 << iota  // a == 1  (iota == 0)
	b = 1 << iota  // b == 2  (iota == 1)
	c = 3          // c == 3  (iota == 2, unused)
	d = 1 << iota  // d == 8  (iota == 3)
)

const (
	u         = iota * 42  // u == 0     (untyped integer constant)
	v float64 = iota * 42  // v == 42.0  (float64 constant)
	w         = iota * 42  // w == 84    (untyped integer constant)
)

const x = iota  // x == 0
const y = iota  // y == 0
```

根据定义，在同一 *ConstSpec* 中多次使用 `iota` 都具有相同的值：

```go
const (
	bit0, mask0 = 1 << iota, 1 << iota - 1  // bit0 == 1, mask0 == 0  (iota == 0)
	bit1, mask1                             // bit1 == 2, mask1 == 1  (iota == 1)
	_, _                                    //                        (iota == 2, unused)
	bit3, mask3                             // bit3 == 8, mask3 == 7  (iota == 3)
)
```

在 Go 中，枚举常量是使用 `iota` 枚举器创建的。由于 `iota` 可以是表达式的一部分，并且表达式可以隐式重复，因此很容易构建复杂的值集。

```go
type ByteSize float64

const (
    _           = iota // ignore first value by assigning to blank identifier
    KB ByteSize = 1 << (10 * iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)
```

>---
#### 变量

变量是用于保存值的存储位置。允许值集由变量的类型决定。一个变量声明、或者对于函数参数和结果、函数声明或函数文本的签名为命名变量保留存储空间。调用内置函数 `new` 或获取复合文本的地址会在运行时为变量分配存储。这种匿名变量是通过（可能是隐式的）指针间接引用的。

数组、切片和结构类型的结构化变量具有可以单独寻址的元素和字段。每个这样的元素都像一个变量。

变量的静态类型（或简称类型）是其声明中给出的类型、`new` 调用或复合文本中提供的类型，或者是结构化变量的元素类型。接口类型的变量也具有不同的动态类型，即在运行时分配给变量的值的（非接口）类型（除非该值是预先声明的标识符 `nil`，它没有类型）。动态类型在执行过程中可能会有所不同，但存储在接口变量中的值始终可分配给变量的静态类型。

```go
var x interface{}  // x is nil and has static type interface{}
var v *T           // v has value nil, static type *T
x = 42             // x has value 42 and dynamic type int
x = v              // x has value (*T)(nil) and dynamic type *T
```

通过引用表达式中的变量来检索变量的值；它是分配给变量的最新值。如果尚未为变量赋值，则其值为其类型的零值。

<br>

##### var：变量声明

变量声明创建一个或多个变量，将相应的标识符绑定到它们，并为每个变量提供类型和初始值。

```ANTLR
VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) 
VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) 
```
```go
var i int
var U, V, W float64
var k = 0
var x, y float32 = -1, -2
var (
	i       int
	u, v, s = 2.0, 3.0, "bar"
)
var re, im = complexSqrt(-1)
var _, found = entries[name]  // map lookup; only interested in "found"
```

如果给出了一个表达式列表，变量将按照赋值语句的规则用表达式初始化。否则，每个变量都被初始化为零值。

如果存在类型，则每个变量都被赋予该类型。否则，每个变量都被赋予赋值中相应初始化值的类型。如果该值是一个无类型的常量，它首先被隐式转换为默认类型；如果它是一个无类型的布尔值，它首先被隐式转换为类型 `bool`。预先声明的值 `nil` 不能用于初始化没有显式类型的变量。

```go
var d = math.Sin(0.5)  // d is float64
var i = 42             // i is int
var t, ok = x.(T)      // t is T, ok is bool
var n = nil            // illegal
```

实现限制：编译器可能会使在函数体中声明一个变量是非法的，如果这个变量从未被使用过。

<br>

##### 短变量声明

短变量声明使用以下语法：

```ANTLR
ShortVarDecl = IdentifierList ":=" ExpressionList 
```

它是带有初始化表达式但没有类型的常规变量声明的简写：

```ANTLR
"var" IdentifierList "=" ExpressionList 
```
```go
i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w, _ := os.Pipe()  // os.Pipe() returns a connected pair of Files and an error, if any
_, y, _ := coord(p)   // coord() returns three values; only interested in y coordinate
```

与常规变量声明不同，短变量声明可以重新声明变量，前提是它们最初在相同类型的同一块（或参数列表，如果块是函数体）中声明的，并且至少有一个非空变量是新的。因此，重新声明只能出现在多变量短声明中。重新声明并不引入新变量；它只是将新值赋给原始变量。`:=` 左侧的非空变量名必须唯一。

```go
field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // redeclares offset
x, y, x := 1, 2, 3                        // illegal: x repeated on left side of :=
```

短变量声明只能出现在函数内部。在某些上下文中，例如 “`if`”、“`for`” 或 “`switch`” 语句的初始化器，它们可以用来声明局部临时变量。

---
### 类型

```ANTLR
Type      = TypeName [ TypeArgs ] | TypeLit | "(" Type ")" 
TypeName  = identifier | QualifiedIdent 
TypeArgs  = "[" TypeList [ "," ] "]" 
TypeList  = Type { "," Type } 
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
            SliceType | MapType | ChannelType 
```

>---
#### Boolean：布尔类型

布尔类型表示由预先声明的常量 `true` 和 `false` 表示的布尔真值集。预先声明的布尔类型是 `bool`；它是一个定义的类型。

>---
#### Numeric：数值类型

整数、浮点或复数类型分别表示整数、浮点或复数值的集合。它们统称为数值类型。预先声明的与体系结构无关的数值类型包括：

```go
uint8       // the set of all unsigned  8-bit integers (0 to 255)
uint16      // the set of all unsigned 16-bit integers (0 to 65535)
uint32      // the set of all unsigned 32-bit integers (0 to 4294967295)
uint64      // the set of all unsigned 64-bit integers (0 to 18446744073709551615)

int8        // the set of all signed  8-bit integers (-128 to 127)
int16       // the set of all signed 16-bit integers (-32768 to 32767)
int32       // the set of all signed 32-bit integers (-2147483648 to 2147483647)
int64       // the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

float32     // the set of all IEEE-754 32-bit floating-point numbers
float64     // the set of all IEEE-754 64-bit floating-point numbers

complex64   // the set of all complex numbers with float32 real and imaginary parts
complex128  // the set of all complex numbers with float64 real and imaginary parts

byte        // alias for uint8
rune        // alias for int32
```

还有一组预先声明的整数类型，这些类型具有特定于实现的大小：

```go
uint        // either 32 or 64 bits
int         // same size as uint
uintptr     // an unsigned integer large enough to store the uninterpreted bits of a pointer value                 
```

为了避免可移植性问题，所有数值类型都是定义的类型，因此除了 `rune` （`int32` 的别名）和 `byte`（`uint8` 的别名）之外，所有数值类型都是不同的。当表达式或赋值中混合使用不同的数值类型时，需要显式转换。`int32` 和 `int` 在特定体系结构上可能具有相同的大小，即使它们也不是同一类型。

>---
#### String：字符串类型

字符串类型表示字符串值的集合。字符串值是一个（可能为空的）字节序列。字节数称为字符串的长度，绝不为负数。字符串是不可变的：一旦创建，就无法更改字符串的内容。预先声明的字符串类型为 `string`，它是一个定义的类型。

可以使用内置函数 `len` 获取字符串 `s` 的长度。如果字符串是常量，则长度 `len(s)` 是编译时常量。字符串的字节可以通过整数索引 `0` 到 `len(s)-1`，单字节用 `byte` 表示。获取此类元素的地址是非法的；如果 `s[i]` 是字符串的第 `i` 个字节，则 `&s[i]` 则无效。

```go
var str = "Hello World"
var lastChar byte = str[len(str)-1]
```

>---
#### Array：数组类型

数组是单一类型的元素的编号序列，称为元素类型。元素的数量称为数组的长度，并且永远不会为负数。

```ANTLR
ArrayType   = "[" ArrayLength "]" ElementType 
ArrayLength = Expression 
ElementType = Type 
```

长度是数组类型的一部分；它的计算结果必须为一个非负常量，该常量可由类型的 `int` 值表示。可以使用内置函数 `len` 来获取数组 `a` 的长度。这些元素可以通过整数索引 `0` 到 `len(a)-1` 来寻址。数组类型始终是一维的，但可以组合成多维类型。

```go
[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // same as [2]([2]([2]float64))
```

如果包含类型的元素仅是数组或结构类型，则数组类型 `T` 不能具有 `type T` 的元素，也不能直接或间接地包含 `T` 作为组件的类型。

```go
// invalid array types
type (
	T1 [10]T1                 // element type of T1 is T1
	T2 [10]struct{ f T2 }     // T2 contains T2 as component of a struct
	T3 [10]T4                 // T3 contains T3 as component of a struct in T4
	T4 struct{ f T3 }         // T4 contains T4 as component of array T3 in a struct
)

// valid array types
type (
	T5 [10]*T5                // T5 contains T5 as component of a pointer
	T6 [10]func() T6          // T6 contains T6 as component of a function type
	T7 [10]struct{ f []T7 }   // T7 contains T7 as component of a slice in a struct
)
```

在规划内存的详细布局时，数组很有用，有时还可以帮助避免分配，但它们主要是切片的构建块。

Go 和 C 中数组的工作方式有很大的不同。在 Go 中：
- 数组是值。将一个数组复制到另一个数组会复制所有元素。
- 特别是，如果将一个数组传递给一个函数，它将收到一个数组的副本，而不是指向它的指针。
- 数组的大小是其类型的一部分。类型 `[10]int` 和 `[20]int` 是不同的。

数组的值属性可能很有用，但也会很昂贵；因此若要类似 C 的行为或效率，可以传递一个指向数组的指针。

```go
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&array)  // Note the explicit address-of operator
```

>---
#### Slice：切片类型

切片是其底层数组的连续段的描述符，提供对该数组中元素的编号序列的访问。切片将数组包装起来，从而给予一个更通用、更强大、更方便的数据序列接口。除了具有显式维度的项目（如转换矩阵）外，Go 语言中的大多数数组编程都是使用切片而不是简单数组完成的。

切片类型表示其元素类型的所有数组切片的集合。元素的数量称为切片的长度，并且永远不会为负数。未初始化切片的值为 `nil`。

```ANTLR
SliceType = "[" "]" ElementType 
```

切片包含对底层数组的引用，如果将一个切片分配给另一个切片，则两者都引用同一个数组。如果一个函数接受一个切片参数，那么它对切片元素所做的修改对调用方来说是可见的，类似于传递一个指向底层数组的指针。

```go
func modifyBySlice(s []int) {
	for i, v := range s {
		s[i] = v * 2
	}
}

var arr = [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
modifyBySlice(arr[:])
fmt.Println(arr)  // [0 2 4 6 8 10 12 14 16 18]
```


切片 `s` 的长度可以通过内置函数 `len`获取；与数组不同，它可能会在执行过程中更改。这些元素可以通过整数索引 `0` 到 `len(s)-1` 来寻址。给定元素的切片索引可能小于底层数组中同一元素的索引。

切片一旦初始化，将始终与保存其元素的底层数组相关联。因此，切片与其数组以及同一数组的其他切片共享存储；相比之下，不同的数组始终表示不同的存储。

切片底层数组可能延伸到切片的末尾。容量是该范围的度量：它是切片长度和切片之外（高位索引方向的）数组长度的总和；通过从原始切片中切出一个新切片，创建长度达到该容量的切片。可以使用内置函数 `cap(s)` 来获取切片 `s` 的容量。对于切片 `s` 与其引用的数组 `a`，始终满足关系式 `len(s) <= cap(s)` 且 `cap(s)` 小于等于数组的长度减去 `s[0]` 在关联数组中的元素的索引，也就是说切片的最大容量不会超过其底层数组的长度。

```go
a := [100]int{}
s := a[10:50]   // 截取数组索引为 10 到 49 的元素
// cap(s) == len(a) - 10  >>> 90
```

可以使用内置函数 `make` 为给定元素类型 `T` 创建一个新的，可选容量大小（`capacity` 为底层数组长度）且长度为 `length`、零值初始化的切片值，若省略容量，则视为 `capacity == length`。 创建切片的 `make` 函数始终分配一个新的隐藏数组，返回的切片值引用该数组。也就是说，执行：

```go
make([]T, length, capacity)
// 等价于
a := [capacity]T{}
s := a[0:length]
```

调用函数与分配一个数组并对其进行切片生成相同的切片对象，因此这两个表达式是等效的：

```go
make([]int, 50, 100)
new([100]int)[0:50]
```

与数组一样，切片始终是一维的，但可以组合成构造更高维的对象。对于数组的数组，内部数组在构造上始终是相同的长度；但是，对于切片的切片（或切片阵列），内部长度可能会动态变化。此外，内部切片必须单独初始化。
<!-- 
内置函数 `append` 可以修改切片的元素，但作为参数的切片本身（保存指针、长度和容量的运行时数据结构）是按值传递的。`append` 生成一个新的隐藏数组，并返回一个新的切片与之关联。

```go

``` -->

<br>

##### 切片表达式

切片表达式从字符串、数组、指向数组的指针、或切片中构造子字符串或切片。有两种变体：一种是指定上限和下限的简单形式，另一种是指定容量上限的完整形式。

> *简单切片表达式*

```go
a[low : high]
```

`a` 的核心类型必须是字符串、数组、指向数组的指针、切片、或 `bytestring`。索引 `low` 和 `high` 选择操作数 `a` 的哪些元素出现在结果中，`low` 和 `high` 满足关系式：`0 <= low <= high <= cap(a) or len(string)`。结果的索引从 0 开始，长度等于 `high - low`。在对数组 `a` 进行切片后：

```go
a := [5]int{1, 2, 3, 4, 5}
s := a[1:4]
```

切片 `s` 具有类型 `[]int` 、长度 `3`、容量 `4` 和元素 `s[0] == 2, s[1] == 3, s[2] == 4`。

为了方便起见，可以省略任何索引。缺失的 `low` 索引默认为零；缺失的 `high` 索引默认为切片操作数的长度：

```go
a[2:]  // same as a[2 : len(a)]
a[:3]  // same as a[0 : 3]
a[:]   // same as a[0 : len(a)]
```

如果 `a` 是指向数组的指针，则 `a[low : high]` 是 `(*a)[low : high]` 的简写。

对于数组或字符串，如果 `0 <= low <= high <= len(a)`，则索引在范围内，否则它们超出范围。对于切片，索引上限是切片容量 `cap(a)` 而不是长度。常量索引必须是非负的，并且可以用类型 `int` 的值表示；对于数组或常量字符串，常量索引也必须在范围内。如果两个索引都是常量，则它们必须满足 `low <= high`。如果索引在运行时超出范围，则会发生运行时异常。

除了无类型字符串，如果切片操作数是字符串或切片，则切片操作的结果是与操作数类型相同的非常量值。对于非类型化的字符串操作数，结果是一个类型为 `string` 的非常量值。如果切片操作数是一个数组，它必须是可寻址的，并且切片操作的结果是一个与数组元素类型相同的切片。

如果有效切片表达式的切片操作数是 `nil` 切片，则结果是 `nil` 切片。否则，如果结果是一个切片，则它与操作数共享其基础数组。

```go
var a [10]int
s1 := a[3:7]   // underlying array of s1 is array a; &s1[2] == &a[5]
s2 := s1[1:4]  // underlying array of s2 is underlying array of s1 which is array a; &s2[1] == &a[5]
s2[1] = 42     // s2[1] == s1[2] == a[5] == 42; they all refer to the same underlying array element

var s []int
s3 := s[:0]    // s3 == nil
```

> *完整切片表达式*

```go
a[low : high : max]
```

`a[low : high : max]` 构造一个与简单切片表达式 `a[low : high]` 相同类型、相同长度和元素的切片。此外，它通过将其设置为 `max - low` 来控制结果切片的容量。只有第一个索引可以省略；它默认为 0。`a` 的核心类型必须是数组、指向数组的指针或切片（但不是字符串）。对数组 `a` 进行切片后：

```go
a := [5]int{1, 2, 3, 4, 5}
t := a[1:3:5]
```

切片 `t` 具有类型 `[]int`、长度 `2`、容量 `4` 和元素 `t[0] == 2, t[1] == 3`。

对于简单的切片表达式，如果 `a` 是指向数组的指针，则 `a[low : high : max]` 是 `(*a)[low : high : max]` 的简写。如果切片操作数是一个数组，它必须是可寻址的。

如果 `0 <= low <= high <= max <= cap(a)`，则索引在范围内，否则它们超出范围。常量索引必须是非负的，并且可以用类型 `int` 的值表示;对于数组，常量索引也必须在范围内。如果多个索引是常量，则存在的常量必须在相对于彼此的范围内。如果索引在运行时超出范围，则会发生运行时异常。

切片实际的容量为底层数组的长度减去切片首元在数组中的索引的值：

```go
a := [100]int{}
s1 := a[20:50:100]   // len = 30, cap = 100-20 = 80
s2 := a[30:50:60]	 // len = 20, cap = 60-30 = 30 
s3 := a[30:50]	     // len = 20, cap = len(a)-30 = 70 
```

<br>

##### 多维切片

Go 语言的数组和切片都是一维的。要创建二维数组或切片的等价物，需要定义一个数组的数组或切片的切片：

```go
type Transform [3][3]float64  // A 3x3 array, really an array of arrays.
type LinesOfText [][]byte     // A slice of byte slices.
```

因为切片是可变长度的，所以可以使每个内部切片具有不同的长度。这可能是一种常见的情况：

```go
text := LinesOfText{
    []byte("Now is the time"),
    []byte("for all good gophers"),
    []byte("to bring some fun to the party."),
}
```

有时需要分配一个二维切片，例如，在处理像素扫描线时可能会出现这种情况。有两种方法可以做到这一点。一种是独立地分配每个切片；另一种是分配一个数组并将各个切片指向其中。

- 首先是一次一行：

	```go
	// Allocate the top-level slice.
	picture := make([][]uint8, YSize) // One row per unit of y.
	// Loop over the rows, allocating the slice for each row.
	for i := range picture {
	    picture[i] = make([]uint8, XSize)
	}
	```

- 先分配再切成行：

	```go
	// Allocate the top-level slice, the same as before.
	picture := make([][]uint8, YSize) // One row per unit of y.
	// Allocate one large slice to hold all the pixels.
	pixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8.
	// Loop over the rows, slicing each row from the front of the remaining pixels slice.
	for i := range picture {
	    picture[i], pixels = pixels[:XSize], pixels[XSize:]
	}
	```

>---
#### Struct：结构类型

结构是一系列命名元素，称为字段，每个元素都有一个名称和一个类型。字段名称可以显式指定（*IdentifierList*）或隐式指定（*EmbeddedField*）。在结构中，非空字段名称必须是唯一的。

```ANTLR
StructType    = "struct" "{" { FieldDecl ";" } "}" 
FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] 
EmbeddedField = [ "*" ] TypeName [ TypeArgs ] 
Tag           = string_literal
```
```go
// An empty struct.
struct {}

// A struct with 6 fields.
struct {
	x, y int
	u float32
	_ float32  // padding
	A *[]int
	F func()
}
```

使用类型声明但没有显式字段名称的字段称为嵌入字段。嵌入字段必须指定为类型名称 `T` 或指向非接口类型名称 `*T` 的指针，并且 `T` 其本身可能不是指针类型。非限定类型名称充当字段名称。

```go
// A struct with four embedded fields of types T1, *T2, P.T3 and *P.T4
struct {
	T1        // field name is T1
	*T2       // field name is T2
	P.T3      // field name is T3
	*P.T4     // field name is T4
	x, y int  // field names are x and y
}
```

以下声明是非法的，因为字段名称在结构类型中必须是唯一的：

```go
struct {
	T     // conflicts with embedded field *T and *P.T
	*T    // conflicts with embedded field T and *P.T
	*P.T  // conflicts with embedded field T and *T
}
```

如果 `x.f` 是表示该字段 `f` 或方法 `f` 的合法选择器（*selector*），则结构体 `x` 中嵌入字段的字段 `f` 或方法 `f` 被称为提升（*promoted*）。提升字段的作用与结构的普通字段类似，只是它们不能用作结构的复合文本中的字段名称。

给定结构类型 `S` 和命名类型 `T`，提升的方法包含在结构的方法集中，如下所示：
- 如果 `S` 包含嵌入字段 `T`，则 `S` 和 `*S` 的方法集都包含带有接收器 `T` 的提升方法。`*S` 的方法集还包括带有接收器 `*T` 的提升方法。
- 如果 `S` 包含嵌入字段 `*T`，则 `S` 和 `*S` 的方法集都包含带有接收器的 `*T` 或 `T` 的提升方法。

字段声明后面可以跟一个可选的字符串文本标记，该标记将成为相应字段声明中所有字段的属性。空标签字符串等同于不存在标签。这些标签通过反射接口可见，并参与结构的类型标识，否则将被忽略。

```go
struct {
	x, y float64 ""  // an empty tag string is like an absent tag
	name string  "any string is permitted as a tag"
	_    [4]byte "ceci n'est pas un champ de structure"
}

// A struct corresponding to a TimeStamp protocol buffer.
// The tag strings define the protocol buffer field numbers;
// they follow the convention outlined by the reflect package.
struct {
	microsec  uint64 `protobuf:"1"`
	serverIP6 uint64 `protobuf:"2"`
}
```

如果包含类型只是数组或结构类型，则结构类型 `T` 不能直接或间接地包含类型 `T` 的字段或包含 `T` 作为组件的类型的字段。

```go
// invalid struct types
type (
	T1 struct{ T1 }            // T1 contains a field of T1
	T2 struct{ f [10]T2 }      // T2 contains T2 as component of an array
	T3 struct{ T4 }            // T3 contains T3 as component of an array in struct T4
	T4 struct{ f [10]T3 }      // T4 contains T4 as component of struct T3 in an array
)

// valid struct types
type (
	T5 struct{ f *T5 }         // T5 contains T5 as component of a pointer
	T6 struct{ f func() T6 }   // T6 contains T6 as component of a function type
	T7 struct{ f [10][]T7 }    // T7 contains T7 as component of a slice in an array
)
```

>---
#### Pointer：指针类型

指针类型表示指向给定类型变量的所有指针的集合，称为指针的基类型。未初始化的指针的值为 `nil`。

```ANTLR
PointerType = "*" BaseType 
BaseType    = Type 
```
```go
*Point
*[4]int
```

>---
#### Function：函数类型

函数类型表示具有相同参数和结果类型的所有函数的集合。函数类型的未初始化变量的值为 `nil`。函数可以返回多个值。

```ANTLR
FunctionType   = "func" Signature 
Signature      = Parameters [ Result ] 
Result         = Parameters | Type 
Parameters     = "(" [ ParameterList [ "," ] ] ")" 
ParameterList  = ParameterDecl { "," ParameterDecl } 
ParameterDecl  = [ IdentifierList ] [ "..." ] Type
```

在参数或结果列表中，名称 （*IdentifierList*） 必须全部存在或全部不存在。如果存在，则每个名称代表指定类型的一个项（参数或结果），并且签名中的所有非空白名称必须是唯一的。如果不存在，则每种类型代表该类型的一个项。参数和结果列表始终带有括号，但如果只有一个未命名的结果，则可以将其写为不带括号的类型。

函数签名中的最后一个传入参数可能具有以 `...` 为前缀的类型。具有此类参数的函数称为可变参数，可以使用该参数的零个或多个参数来调用。

```go
func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)
```

与 C 不同的是，Go 可以返回局部变量或按值传递的函数参数的地址，但无法对常量进行地址运算；与变量相关的存储在函数返回后可以存在。实际上计算复合文本值的地址时，都会分配一个新的实例，因此可以对复合文本进行地址运算：

```go
return &File{fd, name, nil, 0}
```

<br>

##### 函数声明

函数声明将标识符（函数名）绑定到函数。

```ANTLR
FunctionDecl = "func" FunctionName [ TypeParameters ] Signature [ FunctionBody ] 
FunctionName = identifier 
FunctionBody = Block 
```

如果函数的签名声明了结果参数，则函数体的语句列表必须以 *终止语句* 结束。

```go
func IndexRune(s string, r rune) int {
	for i, c := range s {
		if c == r {
			return i
		}
	}
	// invalid: missing return statement
}
```

如果函数声明指定了类型参数，则函数名表示为泛型函数。泛型函数必须先实例化，然后才能作为值调用或使用。

```go
type MInt int
func min[T ~int | ~float64](x, y T) T {
	if x < y {
		return x
	}
	return y
}
rt := min[MInt](10, 20)
```

没有类型参数的函数声明可以省略函数体。这样的声明为在 Go 语言之外实现的函数提供了签名，例如汇编例程。

```go
func flushICache(begin, end uintptr)  // implemented externally
```

<br>

##### 可变参数

如果 `f` 函数包含可变参数，即它的最后一个参数 `p` 的类型为 `...T`，则在 `f` 中，`p` 的类型等价于类型 `[]T`。

```go
func f(arg T1, p ...T){
	// p == []T
}
```

如果调用 `f` 时没有为 `p` 提供实际参数，则传递给 `p` 的值为 `nil`。否则，传递的值是一个类型为 `[]T` 的新切片，带有一个新的底层数组，其后续元素是实际参数，所有这些都必须可分配给 `T`。因此，切片的长度和容量是绑定到 `p` 的参数的数量，并且对于每个调用点可能不同。

```go
func Greeting(prefix string, who ...string)
Greeting("nobody")
Greeting("hello:", "Joe", "Anna", "Eileen")
```

在 `Greeting` 中，`who` 将在第一次调用中具有值 `nil`，而在第二次调用中具有值 `[]string{"Joe", "Anna", "Eileen"}`。

如果最后一个实参可以赋值给切片类型 `[]T`，并且后面跟有 `...`，则它将作为 `...T` 参数的值进行传递。在这种情况下，不会创建新切片。

```go
s := []string{"James", "Jasmine"}
Greeting("goodbye:", s...)
```

在 `Greeting` 中，`who` 将具有与具有相同底层数组 `s` 相同的值。

<br>

##### 函数文本

函数文本可以表示匿名函数，作为函数值赋值给变量或直接调用。函数文本不能声明类型参数。

```ANTLR
FunctionLit = "func" Signature FunctionBody 
```
```go
// 函数文本
func(a, b int, z float64) bool { return a*b < int(z) }

// 赋值变量
f := func(x, y int) int { return x + y }
rt = f(x, y)

// 直接调用
func(ch chan int) { ch <- ACK }(replyChan)   
```

函数文本是闭包：它们可以引用周围函数中定义的变量。然后，这些变量在周围函数和函数文本之间共享，并且只要它们是可访问的，它们就存在。

```go
func Foo() func() {
	var counter = 0
	return func() {
		counter++
		fmt.Printf("%d,", counter)
	}
}
func main() {
	fcounter := Foo()
	for i := 0; i < 10; i++ {
		fcounter()   // 1,2,3,4,5,6,7,8,9,10,
	}
}
```

>---

#### Interface：接口类型

接口类型定义类型集。接口类型的变量可以存储接口类型集中任何类型的值。这样的类型被称为实现接口。接口类型的未初始化变量的值为 `nil`。

```ANTLR
InterfaceType  = "interface" "{" { InterfaceElem ";" } "}" 
InterfaceElem  = MethodElem | TypeElem 
MethodElem     = MethodName Signature 
MethodName     = identifier 
TypeElem       = TypeTerm { "|" TypeTerm } 
TypeTerm       = Type | UnderlyingType 
UnderlyingType = "~" Type 
```

接口类型由接口元素列表指定。接口元素可以是方法，也可以是类型元素，其中类型元素是一个或多个类型项的联合。类型项可以是单个类型，也可以是单个底层类型。

<br>

##### Base Interfaces

在最基本的形式中，接口指定了一个（可能是空的）方法列表。此类接口定义的类型集是实现所有这些方法的类型集，相应的方法集正好由接口指定的方法组成。其类型集可以完全由方法列表定义的接口称为基本接口。

```go
// A simple File interface.
interface {
	Read([]byte) (int, error)
	Write([]byte) (int, error)
	Close() error
}
```

每个显式指定方法的名称必须是唯一的，而不是空的。

```go
interface {
	String() string
	String() string  // illegal: String not unique
	_(x int)         // illegal: method must have non-blank name
}
```

可以有多个类型实现一个接口。例如，如果两个类型 `S1` 和 `S2` 包含了该方法集：

```go
func (p T) Read(p []byte) (n int, err error)
func (p T) Write(p []byte) (n int, err error)
func (p T) Close() error
```

（`T` 可以代表为 `S1` 或 `S2`）`File` 接口由 `S1` 和 `S2` 同时实现，不需要关注 `S1` 和 `S2` 可能拥有或共享其他的什么方法。

作为接口类型集成员的每个类型都实现该接口。任何给定类型都可以实现多个不同的接口。例如，所有类型都实现了空接口，它代表所有（非接口）类型的集合：

```go
interface {}
```

为方便起见，预先声明的类型 `any` 是空接口的别名。

```go
type any = interface{}
```

类似地，以下的接口规范：

```go
type Locker interface {
	Lock()
	Unlock()
}
```

如果 `S1` 和 `S2` 同时实现：

```go
func (p T) Lock() { … }
func (p T) Unlock() { … }
```

它们实现 `Locker` 接口和 `File` 接口。

<br>

##### Embedded interfaces

在一般形式中，接口 `T` 可以使用（可能是限定的）接口类型名称 `E` 作为接口元素。这称为 `T` 中的嵌入式接口 `E`。`T` 的类型集是由 `T` 的显式声明的方法定义的类型集和 `T` 的嵌入式接口的类型集的交集。即，`T` 的类型集是实现 `T` 的所有显式声明的方法以及 `E` 的所有方法的类型集合。
  
```go
type Reader interface {
	Read(p []byte) (n int, err error)
	Close() error
}

type Writer interface {
	Write(p []byte) (n int, err error)
	Close() error
}

// ReadWriter's methods are Read, Write, and Close.
type ReadWriter interface {
	Reader  // includes methods of Reader in ReadWriter's method set
	Writer  // includes methods of Writer in ReadWriter's method set
}
```

嵌入接口时，具有相同名称的方法必须具有相同的签名。

```go
type ReadCloser interface {
	Reader   // includes methods of Reader in ReadCloser's method set
	Close()  // illegal: signatures of Reader.Close and Close are different
}
```

<br>

##### General interfaces

在一般形式中，接口元素可以是任意类型项 `T`，或是指定底层类型 `T` 的 `~T` 形式的项，或是项的联合 `t1 | t2 | … | tn`。与方法规范一起，这些元素使得接口类型集的精确定义如下：
- 空接口的类型集是所有非接口类型的集合。
- 非空接口的类型集是其接口元素的类型集的交集。
- 方法规范的类型集是其方法集包含该方法的所有非接口类型的集合。
- 非接口类型项的类型集是仅由该类型组成的集合。
- 形式为 `~T` 项的类型集是底层类型为 `T` 的所有类型的集合。
- 项 `t1 | t2 | … | tn` 联合的类型集是项类型集的联合。

量化 “所有非接口类型的集合” 不仅指当前程序中声明的所有（非接口）类型，而且指所有可能程序中的所有可能类型，因此是无限制的。类似地，给定特定方法的所有非接口类型的集合，这些类型的方法集的交集将恰好包含该方法，即使程序中的所有类型总是将该方法与另一个方法配对。

根据构造，接口的类型集从不包含接口类型。

```go
// An interface representing only the type int.
interface {
	int
}

// An interface representing all types with underlying type int.
interface {
	~int
}

// An interface representing all types with underlying type int that implement the String method.
interface {
	~int
	String() string
}

// An interface representing an empty type set: there is no type that is both an int and a string.
interface {
	int
	string
}
```

在形式的 `~T` 项中，底层 `T` 类型必须是自身，而 `T` 不能是接口。

```go
type MyInt int

interface {
	~[]byte  // the underlying type of []byte is itself
	~MyInt   // illegal: the underlying type of MyInt is not MyInt
	~error   // illegal: error is an interface
}
```

联合元素表示类型集的联合：

```go
// The Float interface represents all floating-point types
// (including any named types whose underlying types are
// either float32 or float64).
type Float interface {
	~float32 | ~float64
}
```

形式 `T` or `~T` 的项中的类型 `T` 不能是类型参数，并且所有非接口项的类型集必须两两不相交（类型集的两两相交必须为空）。给定一个类型参数 `P`：

```go
interface {
	P                // illegal: P is a type parameter
	int | ~P         // illegal: P is a type parameter
	~int | MyInt     // illegal: the type sets for ~int and MyInt are not disjoint (~int includes MyInt)
	float32 | Float  // overlapping type sets but Float is an interface
}
```

实现限制：联合（具有超过一个项）不能包含预先声明的标识符 `comparable` 或嵌入 `comparable` 的指定方法（或包含该特定方法的接口）。

非基本接口只能用作类型约束，或用作约束的其他接口的元素。它们不能是值或变量的类型，也不能是其他非接口类型的组件。

```go
var x Float                     // illegal: Float is not a basic interface
var x interface{} = Float(nil)  // illegal

type Floatish struct {
	f Float                 // illegal
}
```

接口类型 `T` 不能直接或间接地嵌入、包含于、或是 `T` 的元素。

```go
// illegal: Bad may not embed itself
type Bad interface {
	Bad
}
// illegal: Bad1 may not embed itself using Bad2
type Bad1 interface {
	Bad2
}
type Bad2 interface {
	Bad1
}
// illegal: Bad3 may not embed a union containing Bad3
type Bad3 interface {
	~int | ~string | Bad3
}
// illegal: Bad4 may not embed an array containing Bad4 as element type
type Bad4 interface {
	[10]Bad4
}
```

<br>

##### 实现接口

如果满足以下条件，则类型 `T` 实现接口 `I`：
- `T` 不是接口，是 `I` 类型集合的一个元素；或
- `T` 是一个接口，`T` 的类型集是 `I` 类型集的一个子集。

如果 `T` 实现了接口，则类型 `T` 的值实现了接口。

```go
type (
	ISample interface {
		~int | ~float32 | ~float64
		Foo()
	}
	MInt int
)
func (MInt) Foo() {} // MInt 实现了泛型接口 ISample[int]

func Foo[I ISample](i I) {
	i.Foo()
}
func main() {
	Foo[MInt](10)
}
```

>---
#### Map：映射类型

映射是一种由键值对组成的无序组。未初始化的映射的值为 `nil`。

```ANTLR
MapType     = "map" "[" KeyType "]" ElementType 
KeyType     = Type 
```

映射是一种方便而强大的内置数据结构，它将一种类型（键）的值与另一种类型（元素或值）的值相关联。键可以是定义了相等运算符的任何类型，例如整数、浮点数和复数、字符串、指针、接口（只要动态类型支持相等）、结构和数组。映射和切片不能用作映射键，因为没有在切片和映射上定义相等（只定义了与 `nil` 的相等运算符）。与切片类似，映射包含对底层数据结构的引用。如果将一个映射传递给一个改变映射内容的函数，这些改变将在调用方中可见。

```go
map[string]int
map[*T]struct{ x, y float64 }
map[string]interface{}
```

可以使用常用的复合文字语法和冒号分隔的键值对来构造映射：

```go
var timeZone = map[string]int{
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}

offset := timeZone["EST"]  // 读取映射
```

如果试图使用映射中不存在的键来获取映射值，则映射将返回映射值类型的零值。可以通过多重赋值的方式检查映射是否包含该键。若 `timeZone` 不包含 `tz`，将设置 `rt` 为其类型零值，且 `ok` 设为 `false`；若读取成功则为 `true`，并返回相应的值给 `rt`。

```go
if rt, ok := timeZone[tz]; ok{
	 // read successful
	 // and use rt ... 
}
```

映射类型的元素数量称为其长度。对于映射 `m`，可以使用内置函数 `len` 获取其长度，它可能会在执行过程中更改。

使用内置函数 `make` 创建一个新的空映射值，该函数将映射类型和可选的容量提示作为参数。初始容量不受其大小限制：映射会随着存储项的数量而增长，但 `nil` 映射除外。`nil` 映射等同于空映射，且不能添加任何元素。

```c
make(map[string]int)
make(map[string]int, 100)
```

可以使用赋值在执行过程中添加元素，并使用索引表达式检索元素；它们可以通过 `delete` 和 `clear` 内置功能删除。

```go
var s_map map[string]bool = make(map[string]bool)

// 添加元素
s_map["a"] = true
s_map["b"] = true
s_map["c"] = true
s_map["d"] = true
s_map["e"] = true
s_map["f"] = true

// 删除或清空
delete(s_map, "a")
clear(s_map)
```

>---
#### Channel：通道类型

通道提供了一种机制，用于并发执行函数，以便通过发送和接收指定元素类型的值进行通信。未初始化通道的值为 `nil`。

```ANTLR
ChannelType = ( "chan" | "chan" "<-" | "<-" "chan" ) ElementType 
```

可选 `<-` 运算符指定通道方向、发送或接收。如果给出了方向，则通道是定向的，否则它是双向的。通道可能被限制为仅发送或仅通过分配或显式转换进行接收。

```go
chan T          // can be used to send and receive values of type T
chan<- float64  // can only be used to send float64s
<-chan int      // can only be used to receive ints
```

`<-` 运算符尽可能与最左边的 `chan` 相关联：

```go
chan<- chan int    // same as chan<- (chan int)
chan<- <-chan int  // same as chan<- (<-chan int)
<-chan <-chan int  // same as <-chan (<-chan int)
chan (<-chan int)
```

可以使用内置函数 `make` 创建一个新的初始化通道值，该函数将通道类型和可选容量作为参数：

```go
make(chan int, 100)
```

容量（以元素数表示）设置通道中缓冲区的大小。如果容量为零或不存在，则信道是无缓冲的，只有当发送方和接收方都准备就绪时，通信才会成功。否则，如果缓冲区未满（发送）或未空（接收），则通道将缓冲，并且通信成功而不会阻塞。 `nil` 通道永远无法进行通信。

可以使用内置函数 `close` 关闭通道。*接收运算符* 的多值分配表报告是否在通道关闭之前发送了接收值。

单个通道可用于发送语句、接收操作和对内置函数 `cap` 和 `len` 的任意数目的 *goroutine* 调用，而无需进一步同步。通道充当先进先出队列。例如，如果一个 *goroutine* 在通道上发送值，而另一个 *goroutine* 接收这些值，则将按发送顺序接收这些值。

>---
#### 类型别名与类型定义

`type` 用以创建类型别名或声明类型定义。类型别名与原类型等价，而类型定义是定义一种新的类型

```go
type byte uint8				// byte 是 uint8 的别名
type myString = string		// myString 是新类型定义


type myString string
var myStr myString = "Hello"
var b byte = myStr[0]

fmt.Printf("myStr is %T\n", myStr)		// myStr is main.myString
fmt.Printf("b is %T\n", b)				// b is uint8
```

>---
#### 类型和值的属性

##### 底层类型

每个类型 `T` 都有一个底层类型：如果是预声明的布尔类型、数值类型或字符串类型之一，或者是类型文本，则 `T` 相应的底层类型就是 `T` 其本身。否则，`T` 的底层类型是其声明中 `T` 引用的类型的底层类型。对于类型参数，该参数是其类型约束的底层类型，该约束始终是接口。

```go
type (
	A1 = string
	A2 = A1
)

type (
	B1 string
	B2 B1
	B3 []B1
	B4 B3
)

func f[P any](x P) { … }
```

`string`、`A1`、`A2`、`B1`、`B2` 的底层类型均为 `string`，`[]B1`、`B3`、`B4` 的底层类型为 `[]B1`。`P` 的底层类型是 `interface {}`。

<br>

##### 核心类型

每个非接口类型 `T` 都有一个核心类型（*core type*），该类型与底层类型 `T` 相同。

如果满足以下条件之一，则接口 `T` 具有核心类型：
- 有一个单一类型 `U`，它是 `T` 类型集合中所有类型的底层类型；或
- `T` 的类型集只包含具有相同元素类型 `E` 的通道类型，且所有具有方向的通道方向相同。

没有其他接口具有核心类型。根据满足的条件，接口的核心类型是：
- 类型 `U`；
- 如果 `T` 只包含双向通道，或者是取决于存在的定向通道的方向的类型 `chan<- E` 或 `<-chan E`，则核心类型是通道 `chan E`。

根据定义，核心类型从来都不是定义的类型、类型参数或接口类型。

具有核心类型的接口示例：

```go
type Celsius float32
type Kelvin  float32

interface{ int }                          // int
interface{ Celsius|Kelvin }               // float32
interface{ ~chan int }                    // chan int
interface{ ~chan int|~chan<- int }        // chan<- int
interface{ ~[]*data; String() string }    // []*data
```

不带核心类型的接口示例：

```go
interface{}                               // no single underlying type
interface{ Celsius|float64 }              // no single underlying type
interface{ chan int | chan<- string }     // channels have different element types
interface{ <-chan int | chan<- int }      // directional channels have different directions
```

一些操作（切片表达式，拼接和复制）依赖于接受字节切片和字符串切片的稍微宽松的内核类型形式。具体来说，如果有恰好两种类型 `[]byte` 和 `string`，它们是接口 `T` 类型集中所有类型的底层类型，`T` 的核心类型称为 `bytestring`。

具有 `bytestring` 核心类型的接口示例：

```go
interface{ int }                          // int (same as ordinary core type)
interface{ []byte | string }              // bytestring
interface{ ~[]byte | myString }           // bytestring
```

`bytestring` 不是一个真实的类型；它不能用于声明变量或组合其他类型的类型。它的存在只是为了描述从字节序列（可能是字节切片或字符串）读取的某些操作的行为。

<br>

##### 类型标识符

两种类型要么相同，要么不同。

命名类型始终不同于任何其他类型。否则，如果两个类型的底层类型文本在结构上等效，则它们相同；也就是说，它们具有相同的文本结构，相应的组件具有相同的类型。具体如下：
- 如果两种数组类型具有相同的元素类型和相同的数组长度，则它们相同。
- 如果两个切片类型具有相同的元素类型，则它们相同。
- 如果两个结构类型具有相同的字段序列，并且相应的字段具有相同的名称、相同的类型和相同的标记，则它们相同。来自不同包的非导出字段名称始终不同。
- 如果两个指针类型具有相同的基类型，则它们是相同的。
- 如果两个函数类型具有相同数量的参数和结果值，则它们相同，相应的参数和结果类型相同，并且两个函数都是可变的，或者都不是。参数和结果名称不需要匹配。
- 如果两个接口类型定义相同的类型集，则它们相同。
- 如果两种映射类型具有相同的键和元素类型，则它们相同。
- 如果两种通道类型具有相同的元素类型和相同的方向，则它们相同。
- 如果两个实例化类型的定义类型和所有类型参数相同，则它们相同。

```go
// 声明
type (
	A0 = []string
	A1 = A0
	A2 = struct{ a, b int }
	A3 = int
	A4 = func(A3, float64) *A0
	A5 = func(x int, _ float64) *[]string

	B0 A0
	B1 []string
	B2 struct{ a, b int }
	B3 struct{ a, c int }
	B4 func(int, float64) *B0
	B5 func(x int, y float64) *A1

	C0 = B0
	D0[P1, P2 any] struct{ x P1; y P2 }
	E0 = D0[int, string]
)

/* 其中以下类型是相同的
A0, A1, []string
A2, struct{ a, b int }
A3, int
A4, func(int, float64) *[]string, A5

B0, C0
D0[int, string], E0
func(x int, y float64) *[]string, func(int, float64) (result *[]string), A5
*/
```

`B0` 和 `B1` 是不同的，因为它们是由不同的类型定义创建的新类型；`func(int, float64) *B0` 和 `func(x int, y float64) *[]string` 不同，因为 `B0` 不同于 `[]string`；`P1` 和 `P2` 是不同的，因为它们是不同的类型参数。`D0[int, string]` 和 `struct{ x int; y string }` 是不同的，因为前者是实例化的已定义类型，而后者是类型文本（但它们仍然具有可分配性）。

<br>

##### 可分配性 

类型 `V` 的值 `x` 如果满足以下条件之一时，值 `x` 可分配给类型 `T` 的变量（“ `x` 可赋值给 `T` ”）：
- `V` 和 `T` 是相同的。
- `V` 和 `T` 具有相同的底层类型，但不是类型参数，并且 `V` 或 `T` 中至少有一个不是命名类型。
- `V` 和 `T` 是具有相同元素类型的通道类型，`V` 是双向通道，并且 `V` 或 `T` 中至少有一个不是命名类型。
- `T` 是接口类型，但不是类型参数，`x` 实现了 `T`。
- `x` 是预先声明的标识符 `nil`，`T` 是指针、函数、切片、映射、通道或接口类型，但不是类型参数。
- `x` 是一个无类型的常量，可以用类型 `T` 的值表示。

此外，如果 `x` 的类型 `V` 或 `T` 是类型参数，则如果以下条件之一适用，则 `x` 可分配给类型 `T` 的变量：
- `x` 是预先声明的标识符 `nil`，`T` 是类型参数，`x` 可分配给 `T` 的类型集中的每个类型。
- `V` 不是命名类型，`T` 是类型参数，`x` 可分配给 `T` 的类型集中的每个类型。
- `V` 是类型参数，`T` 不是命名类型，`V` 的类型集中的每个类型的值都可以分配给 `T`。

<br>

##### 可代表性

如果以下条件之一适用。常量 `x` 可由类型 `T` 的值表示，其中 `T` 不是类型参数：
- `x` 在由 `T` 确定的值集合中。
- `T` 是浮点类型，`x` 可以舍入到 `T` 的精度而不会溢出。舍入使用 IEEE 754 舍入到偶数规则，但将 IEEE 负零进一步简化为无符号零。请注意，常量值永远不会导致 IEEE 负零、NaN 或无穷大。
- `T` 是一个复数类型，`x` 的组件 `real(x)` 和 `imag(x)` 可以由 `T` 的组件类型（`float32` 或 `float64`）的值表示。

如果 `T` 是一个类型参数，那么如果 `x` 可以由 `T` 的类型集中的每个类型的值表示，那么 `x` 可以由类型 `T` 的值表示。

```go
x                   T           // x is representable by a value of T because

'a'                 byte        // 97 is in the set of byte values
97                  rune        // rune is an alias for int32, and 97 is in the set of 32-bit integers
"foo"               string      // "foo" is in the set of string values
1024                int16       // 1024 is in the set of 16-bit integers
42.0                byte        // 42 is in the set of unsigned 8-bit integers
1e10                uint64      // 10000000000 is in the set of unsigned 64-bit integers
2.718281828459045   float32     // 2.718281828459045 rounds to 2.7182817 which is in the set of float32 values
-1e-1000            float64     // -1e-1000 rounds to IEEE -0.0 which is further simplified to 0.0
0i                  int         // 0 is an integer value
(42 + 0i)           float32     // 42.0 (with zero imaginary part) is in the set of float32 values
```
```go
x                   T           // x is not representable by a value of T because

0                   bool        // 0 is not in the set of boolean values
'a'                 string      // 'a' is a rune, it is not in the set of string values
1024                byte        // 1024 is not in the set of unsigned 8-bit integers
-1                  uint16      // -1 is not in the set of unsigned 16-bit integers
1.1                 int         // 1.1 is not an integer value
42i                 float32     // (0 + 42i) is not in the set of float32 values
1e1000              float64     // 1e1000 overflows to IEEE +Inf after rounding
```

---
### 复合文本

复合文本的每次求值，都会构造一个新的复合值。它们由文本的类型和一个花括号绑定的元素列表组成。每个元素前面可以有一个相应的键。

```ANTLR
CompositeLit  = LiteralType LiteralValue 
LiteralType   = StructType | ArrayType | "[" "..." "]" ElementType |
                SliceType | MapType | TypeName [ TypeArgs ] 
LiteralValue  = "{" [ ElementList [ "," ] ] "}" 
ElementList   = KeyedElement { "," KeyedElement } 
KeyedElement  = [ Key ":" ] Element 
Key           = FieldName | Expression | LiteralValue 
FieldName     = identifier 
Element       = Expression | LiteralValue 
```

*LiteralType* 的核心类型 `T` 必须是 `struct`、`array`、`slice` 或 `map` 类型（语法强制执行此约束，除非该类型作为 *TypeName* 给出）。元素和键的类型必须可分配给类型 `T` 的相应字段、元素和键类型；没有额外的转换。

复合文本的字段按顺序排列，并且必须全部存在；但是可以显式地标记为 *field : value* 对，初始化设定项可以以任何顺序出现，缺失的初始化设定项保留为它们各自的零值。对于不同类型的复合文本，*field* 被解释为结构文本的字段名称、数组和切片文本的索引以及映射文本的键。对于映射文本，所有元素都必须有一个键。使用相同的字段名或常量键值指定多个元素是错误的。

>---

#### 结构文本

以下规则适用于结构文本：
- 键必须是在结构类型中声明的字段名。
- 不包含任何键的元素列表必须按照声明字段的顺序为每个结构字段列出一个元素。
- 如果任何元素都有键，那么每个元素都必须有键。
- 包含键的元素列表不需要每个结构字段都有一个元素。省略的字段将获得该字段的零值。 
- 一个文本可以省略元素列表；这样的文本计算为它的类型的零值。
- 为属于不同包的结构的非导出字段指定元素是错误的。

```go
type Point3D struct { x, y, z float64 }
type Line struct { p, q Point3D }

origin := Point3D{}                            // zero value for Point3D
line := Line{origin, Point3D{y: -4, z: 12.3}}  // zero value for line.q.x
```

>---

#### 数组、切片和映射文本

以下规则适用于数组和切片文本：
- 每个元素都有一个相关的整数索引，标记它在数组中的位置。
- 有键的元素使用键作为其索引。键必须是一个非负常量，可以用类型为 `int` 的值表示；如果它是类型定义的，则必须是整数类型。
- 没有键的元素使用前一个元素的索引加 1。如果第一个元素没有键，则其索引为零。

```go
var arr = [5]int{0, 1: 0, 3: 3, 4}   // arr[2] == 0
arr[2] = 2
```

获取复合文本的地址会生成一个指针，指向一个用文本值初始化的唯一变量。

```go
var pointer *Point3D = &Point3D{y: 1000}
```

切片或映射类型的零值与相同类型的初始化但为空的值不同。因此，获取空切片或映射复合文本的地址与使用 `new` 分配新切片或映射值的效果不同。

```go
p1 := &[]int{}    // p1 points to an initialized, empty slice with value []int{} and length 0
p2 := new([]int)  // p2 points to an uninitialized slice with value nil and length 0
```

数组文本的长度是文本类型中指定的长度。如果文本中提供的元素少于长度，则缺失的元素将设置为数组元素类型的零值。提供索引值超出数组索引范围的元素是错误的。符号 `...` 指定数组长度等于最大元素索引加 1。

```go
buffer := [10]string{}             // len(buffer) == 10
intSet := [6]int{1, 2, 3, 5}       // len(intSet) == 6
days := [...]string{"Sat", "Sun"}  // len(days) == 2
```

切片文本描述了整个底层数组文本。因此，切片文本的长度和容量是最大元素索引加 1。切片文本的形式为：

```go
slice := []T{x1, x2, … xn}
```

它是应用于数组 `[...]T{x1, x2, … xn}` 的切片操作的简写：

```go
tmp := [n]T{x1, x2, … xn}
slice := tmp[0 : n]  
```

在数组、切片或映射类型 `T` 的复合文本中，如果文本与 `T` 的元素或键类型相同，本身又是复合文本的元素或映射键时，可以省略相应的文本类型。类似地，当元素或键类型为 `*T` 时，作为复合文本地址的元素或键可以省略 `&T`。

```go
[...]Point{{1.5, -3.5}, {0, 0}}     // same as [...]Point{Point{1.5, -3.5}, Point{0, 0}}
[][]int{{1, 2, 3}, {4, 5}}          // same as [][]int{[]int{1, 2, 3}, []int{4, 5}}
[][]Point{{{0, 1}, {1, 2}}}         // same as [][]Point{[]Point{Point{0, 1}, Point{1, 2}}}
map[string]Point{"orig": {0, 0}}    // same as map[string]Point{"orig": Point{0, 0}}
map[Point]string{{0, 0}: "orig"}    // same as map[Point]string{Point{0, 0}: "orig"}

type PPoint *Point
[2]*Point{{1.5, -3.5}, {}}          // same as [2]*Point{&Point{1.5, -3.5}, &Point{}}
[2]PPoint{{1.5, -3.5}, {}}          // same as [2]PPoint{PPoint(&Point{1.5, -3.5}), PPoint(&Point{})}
```

当使用 *LiteralType* 的 *TypeName* 形式的复合文本作为操作数出现在 “`if`”、“`for`” 或 “`switch`” 语句的关键字和块的左括号之间，并且复合文本没有包含在括号、方括号或花括号中时，就会出现解析歧义。在这种罕见的情况下，字面量的左括号被错误地解析为引入语句块的括号。若要解决多义性，复合文本必须出现在括号内。

```go
if x == (T{a,b,c}[i]) { … }
if (x == T{a,b,c}[i]) { … }
```

有效数组、切片和映射文本的示例：

```go
// list of prime numbers
primes := []int{2, 3, 5, 7, 9, 2147483647}

// vowels[ch] is true if ch is a vowel
vowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}

// the array [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}
filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}

// frequencies in Hz for equal-tempered scale (A4 = 440Hz)
noteFrequency := map[string]float32{
	"C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,
	"G0": 24.50, "A0": 27.50, "B0": 30.87,
}
```

---
### 选择器

对于非包名的主表达式 `x`，选择器表达式 `x.f` 表示值 `x` 的字段或方法 `f`（或有时 `*x`，`x.f` 是 `(*x).f` 的简写）。标识符 `f` 被称为（字段或方法）选择器；它不能是空标识符（`_`）。选择器表达式的类型是 `f` 的类型。如果 `x` 是一个包名，则 `f` 是该包的导出限定标识符，例如 `math.Sin`。

选择器 `f` 可以表示类型 `T` 的字段或方法 `f`，或者它可以指 `T` 的嵌套嵌入字段的字段或方法 `f`。到达 `f` 所遍历的嵌入字段的数量称为其在 `T` 中的深度。在 `T` 中声明的字段或方法 `f` 的深度为零。在 `T` 中的嵌入字段 `A` 中声明的字段或方法 `f` 的深度是 `A` 中的 `f` 的深度加 1。

以下规则适用于选择器：
- 对于类型 `T` 或 `*T` 的值 `x`，其中 `T` 不是指针或接口类型，`x.f` 表示在 `T` 中最浅深度处的字段或方法，其中存在这样的 `f`。如果没有一个 `f` 具有最浅的深度，则选择器表达式是非法的。
- 对于类型 `I` 的值 `x`，其中 `I` 是接口类型，`x.f` 表示具有动态值 `x` 的名称 `f` 的实际方法。如果在 `I` 的方法集中没有名为 `f` 的方法，则选择器表达式是非法的。
- 作为例外，如果 `x` 的类型是定义的指针类型，而 `(*x).f` 是表示字段（但不是方法）的有效选择器表达式，则 `x.f` 是 `(*x).f` 的简写。
- 在所有其他情况下，`x.f` 都是非法的。
- 如果 `x` 是指针类型，并且具有值 `nil`，而 `x.f` 表示结构字段，则分配或求值 `x.f` 会导致运行时异常。
- 如果 `x` 是接口类型并且值为 `nil`，则调用或求值方法 `x.f` 会导致运行时异常。

```go
// 给定声明
type T0 struct {
	x int
}
func (*T0) M0()

type T1 struct {
	y int
}
func (T1) M1()
type T2 struct {
	z int
	T1
	*T0
}
func (*T2) M2()
type Q *T2

var t T2     // with t.T0 != nil
var p *T2    // with p != nil and (*p).T0 != nil
var q Q = p
```
```go
// 如下调用
t.z          // t.z
t.y          // t.T1.y
t.x          // (*t.T0).x

p.z          // (*p).z
p.y          // (*p).T1.y
p.x          // (*(*p).T0).x

q.x          // (*(*q).T0).x        (*q).x is a valid field selector

p.M0()       // ((*p).T0).M0()      M0 expects *T0 receiver
p.M1()       // ((*p).T1).M1()      M1 expects T1 receiver
p.M2()       // p.M2()              M2 expects *T2 receiver
t.M2()       // (&t).M2()           M2 expects *T2 receiver, see section on Calls

// 无效调用
q.M0()       // (*q).M0 is valid but not a field selector, Q 是类型定义，非 *T2 别名
// 若 type Q = *T2, 则 q.M0() 成立
```

---
### 方法与接收器

#### 方法声明

方法是一个带有接收器的函数。方法声明将标识符（方法名）绑定到方法，并将该方法与接收方的基类型相关联。可以为任何命名类型（除了指针或接口）定义方法；接收器不必是结构体。

```ANTLR
MethodDecl = "func" Receiver MethodName Signature [ FunctionBody ] 
Receiver   = Parameters 
```

接收器是通过方法名前面的一个额外的参数部分指定的。该参数部分必须声明一个非可变参数，即接收器。它的类型必须是已定义的类型 `T` 或指向已定义的类型 `T` 的指针，后面可能有一个用方括号括起来的类型参数名称列表 `[P1, P2, …]`。`T` 被称为接收器基类型。接收器基类型不能是指针或接口类型，并且它必须与方法定义在同一个包中。方法被绑定到它的接收器基类型，并且方法名称仅在类型 `T` 或 `*T` 的选择器中可见。

```go
func (p Point) Length() float64 {				// receiver is Point
	return math.Sqrt(p.x * p.x + p.y * p.y)
}
func (p *Point) Scale(factor float64) {    	    // receiver is *Point
	p.x *= factor
	p.y *= factor
}
```

非空的接收方标识符在方法签名中必须是唯一的。如果接收器的值没有在方法体中引用，则其标识符可以在声明中省略。这同样适用于函数和方法的参数。

```go
func (Receiver) Foo(int)			// 省略接收器和参数的标识符
```

对于基类型，绑定到它的方法的非空名称必须唯一。如果基类型是结构类型，则非空的方法名和字段名必须是不同的。

```go
type S struct {
	Value int
}
func (s S) Foo() {}   // 方法名与结构体成员的名称不能重复
```

如果接收器基类型是泛型类型，则接收器规范必须声明要使用的方法的相应类型参数。这使得接收器的类型参数可用于该方法。从语法上讲，这个类型参数声明看起来像是接收器基类型的实例化：类型参数必须是表示被声明的类型参数的标识符，接收器基类型的每个类型参数都有一个。类型参数名称不需要与接收器基类型定义中相应的参数名称相匹配，并且所有非空参数名称在接收器参数部分和方法签名中必须是唯一的。接收器类型参数约束由接收器基类型定义隐含：对应的类型参数具有对应的约束。

```go
type Pair[A, B any] struct {
	a A
	b B
}
func (p Pair[A, B]) Swap() Pair[B, A]  { … }  // receiver declares A, B
func (p Pair[First, _]) First() First  { … }  // receiver declares First, corresponds to A in Pair
```


>---
#### 方法集

类型的方法集决定了可以对该类型的操作数调用的方法。每个类型都有一个（可能是空的）与之关联的方法集：
- 定义的类型 `T` 的方法集由所有使用接收器类型 `T` 声明的方法组成。
- 指向已定义类型 `T` 的指针的方法集（其中 `T` 既不是指针也不是接口）是使用接收器 `*T` 或 `T` 声明的所有方法的集合。
- 接口类型的方法集是接口类型集中每个类型的方法集的交集（结果方法集通常只是接口中声明的方法集）。

进一步的规则适用于包含嵌入字段的结构（和指向结构的指针），如结构类型部分所述。任何其他类型都有一个空的方法集。

在方法集中，每个方法必须有唯一的非空方法名.


>---
#### 方法表达式

如果 `M` 在类型为 `T` 的方法集中，则方法表达式 `T.M` 是一个可作为常规函数调用的函数，除了将方法接收器的值作为 `T.M` 的第一个参数，其余参数与 `M` 相同。

```ANTLR
MethodExpr    = ReceiverType "." MethodName 
ReceiverType  = Type 
```

例如一个类型为 `T` 的结构体，它有两个方法：`Mv`，其接收器类型为 `T`；`Mp`，其接收器类型为 `*T`。

```go
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver
```

方法表达式 `T.Mv` 生成一个与 `Mv` 等效的函数，但它的第一个参数是显式的接收器；它有签名 `func(tv T, a int) int`。该函数可以通过显式接收器正常调用，因此这五个调用是等效的：

```go
var t T

t.Mv(7)
T.Mv(t, 7)
(T).Mv(t, 7)
f1 := T.Mv; f1(t, 7)
f2 := (T).Mv; f2(t, 7)
```

方法表达式 `(*T).Mp` 也生成一个函数值，表示带有签名的 `Mp`：`func(tp *T, f float32) float32`。

对于具有值接收器的方法 `T.Mv`，可以导出具有显式指针接收器的函数 `(*T).Mv`，即生成函数值 `func(tv *T, a int) int`。这样的函数通过接收器间接创建一个值，并作为接收器传递给底层方法；方法不会覆盖在函数调用中传递的地址的值。

```go
f := (*T).Mv; f(&T{1}, 1)
```

最后一种情况，指针接收器方法的值接收器函数（`(T).Mp`）是非法的，因为指针接收器方法不在值类型的方法集中。从方法派生的函数值是用函数调用语法调用的；接收器作为调用的第一个参数提供。也就是说，给定 `f := T.Mv`，`f` 被调用为 `f(t, 7)` 而不是 `t.f(7)`。若要构造绑定接收方的函数，请使用函数文本（匿名函数）或方法值（例如 `T.Mv`）。

```go
f1 := T.Mp       // illegal
f2 := (*T).Mp    // legal, func(tp *T, a float32) float32
f3 := (*T).Mv	 // func(tv *T, a int) int
```

从接口类型的方法派生函数值是合法的。结果函数接受该接口类型的显式接收器。

>---
#### 方法值

如果表达式 `x` 具有静态类型 `T`，并且 `M` 在类型 `T` 的方法集中，则 `x.M` 被称为方法值。方法值 `x.M` 是一个函数值，可以使用与 `x.M` 的方法调用相同的参数进行调用。表达式 `x` 在方法值的计算过程中被计算和保存；保存的副本可以在任何调用中用作接收器，这些调用可能在以后执行。

```go
type S struct { *T }
type T int
func (t T) M() { print(t) }

t := new(T)
s := S{T: t}
f := t.M                    // receiver *t is evaluated and stored in f
g := s.M                    // receiver *(s.T) is evaluated and stored in g
*t = 42                     // does not affect stored receivers in f and g
```

类型 `T` 可以是接口或非接口类型。与上面讨论的方法表达式一样，考虑一个结构类型 `T`，它有两个方法：`Mv`，其接收器是类型 `T`；`Mp`，其接收器是类型 `*T`。

```go
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver

var t T
var pt *T
func makeT() T
```

表达式 `t.Mv` 生成类型为 `func(int) int` 的函数值，`t.Mv(7)` 和 `f := t.Mv; f(7)` 这两个调用是等效的。表达式 `pt.Mp` 生成类型为 `func(float32) float32` 的函数值。

与选择器一样，使用指针引用具有值接收器的非接口方法将自动取消引用该指针：`pt.Mv` 等效于 `(*pt).Mv`。与方法调用一样，对具有指针接收器的非接口方法的引用使用可寻址值将自动获取该值的地址：`t.Mp` 等效于 `(&t).Mp`。

```go
f := t.Mv; f(7)   // like t.Mv(7)
f := pt.Mp; f(7)  // like pt.Mp(7)
f := pt.Mv; f(7)  // like (*pt).Mv(7)
f := t.Mp; f(7)   // like (&t).Mp(7)
f := makeT().Mp   // invalid: result of makeT() is not addressable
```

虽然上面的例子使用了非接口类型，但是从接口类型的值创建方法值也是合法的。

```go
var i interface { M(int) } = myVal
f := i.M; f(7)  // like i.M(7)
```

>---
#### 方法调用

给定一个表达式 `f`，其核心类型 `F` 为函数类型：

```go
f(a1, a2, … an)
```

使用参数 `a1`, `a2`, … `an` 调用 `f`。除了一种特殊情况，参数必须是可分配给 `F` 的参数类型的单值表达式，并且在调用函数之前进行计算。表达式的类型是 `F` 的结果类型。方法调用与此类似，但方法本身被指定为方法的接收器类型值的选择器。

```go
math.Atan2(x, y)  // function call
var pt *Point
pt.Scale(3.5)     // method call with receiver pt
```

如果 `f` 表示泛型函数，则必须先实例化它，然后才能将其作为函数值调用或使用。

在函数调用中，函数值和参数按通常的顺序计算。在对参数求值后，调用的参数将按值传递给函数，被调用的函数开始执行。当函数返回时，函数的返回参数按值传递回调用方。调用 `nil` 函数值会导致运行时异常。

作为特殊情况，如果一个函数或方法 `g` 的返回值在数量上相等，并且可以单独分配给另一个函数或方法 `f` 的参数，那么调用 `f(g(parameters_of_g))` 将在按顺序将 `g` 的返回值绑定到 `f` 的参数之后调用 `f`。`f` 的调用必须不包含除 `g` 的调用之外的任何参数，并且 `g` 必须至少有一个返回值。如果 `f` 有一个最终的 `...` 参数，它将被分配在常规参数分配后剩余的 `g` 返回值。

```go
func Split(s string, pos int) (string, string) {
	return s[0:pos], s[pos:]
}
func Join(s, t string) string {
	return s + t
}

if Join(Split(value, len(value)/2)) != value {
	log.Panic("test fails")
}
```

如果 `x` 的方法集（的类型）包含 `m`，并且参数列表可以分配给 `m` 的参数列表，则方法调用 `x.m()` 有效。如果 `x` 是可寻址的，而 `&x` 的方法集包含 `m`，则 `x.m()` 是 `(&x).m()` 的简写：

```go
var p Point
p.Scale(3.5)
```

没有明确的方法类型，也没有方法文本。

---
### 命名类型

类型声明将标识符（类型名称）绑定到类型。类型声明有两种形式：别名声明和类型定义。它们被称为命名类型。

```ANTLR
TypeDecl = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) 
TypeSpec = AliasDecl | TypeDef 
```

>---

#### 别名声明

别名声明将标识符绑定到给定类型。

```ANTLR
AliasDecl = identifier "=" Type
```

在标识符的范围内，它充当类型的别名。

```go
type (
	nodeList = []*Node  // nodeList and []*Node are identical types
	Polar    = polar    // Polar and polar denote identical types
)
```

>---

#### 类型定义

类型定义创建一个具有与给定类型相同的底层类型和操作的新的不同类型，并将标识符（类型名称）绑定到该类型。

```ANTLR
TypeDef = identifier [ TypeParameters ] Type 
```

新类型称为定义类型。它不同于任何其他类型，包括创建它的类型。

```go
type (
	Point struct{ x, y float64 }  // Point and struct{ x, y float64 } are different types
	polar Point                   // polar and Point denote different types
)

type TreeNode struct {
	left, right *TreeNode
	value any
}

type Block interface {
	BlockSize() int
	Encrypt(src, dst []byte)
	Decrypt(src, dst []byte)
}
```

定义的类型可以有与之关联的方法。**它不继承任何绑定到给定类型的方法**，但接口类型或复合类型的元素的方法集保持不变：

```go
// A Mutex is a data type with two methods, Lock and Unlock.
type Mutex struct         { /* Mutex fields */ }
func (m *Mutex) Lock()    { /* Lock implementation */ }
func (m *Mutex) Unlock()  { /* Unlock implementation */ }

// NewMutex has the same composition as Mutex but its method set is empty.
type NewMutex Mutex

// The method set of PtrMutex's underlying type *Mutex remains unchanged,
// but the method set of PtrMutex is empty.
type PtrMutex *Mutex

// The method set of *PrintableMutex contains the methods
// Lock and Unlock bound to its embedded field Mutex.
type PrintableMutex struct {
	Mutex
}

// MyBlock is an interface type that has the same method set as Block.
type MyBlock Block
```

类型定义可用于定义不同的布尔、数值或字符串类型，并将方法与它们相关联：

```go
type TimeZone int

const (
	EST TimeZone = -(5 + iota)
	CST
	MST
	PST
)

func (tz TimeZone) String() string {
	return fmt.Sprintf("GMT%+dh", tz)
}
```

如果类型定义指定了类型参数，则命名类型表示泛型类型。泛型类型在使用时必须实例化。

```go
type List[T any] struct {
	next  *List[T]
	value T
}
```

在类型定义中，给定的类型不能是类型参数。

```go
type T[P any] P    // illegal: P is a type parameter

func f[T any]() {
	type L T   // illegal: T is a type parameter declared by the enclosing function
}
```

一个泛型类型也可以有与之关联的方法。在这种情况下，方法接收器必须声明与泛型类型定义中相同数量的类型参数。

```go
// The method Len returns the number of elements in the linked list l.
func (l *List[T]) Len() int  { … }
```

---
### 泛型声明

#### 类型参数声明

类型参数列表声明泛型函数或类型声明的类型参数。类型参数列表看起来像一个普通的函数参数列表，除了类型参数名称必须全部存在，并且列表用方括号而不是圆括号括起来。

```ANTLR
TypeParameters  = "[" TypeParamList [ "," ] "]" 
TypeParamList   = TypeParamDecl { "," TypeParamDecl } 
TypeParamDecl   = IdentifierList TypeConstraint 
```

当泛型类型的类型参数列表声明了一个带有约束 `C` 的单个类型参数 `P`，使得文本 `P C` 形成一个有效表达式时，就会出现解析二义性：

```go
type T[P *C] …
type T[P (C)] …
type T[P *C|Q] …
…
```

在这些罕见的情况下，类型参数列表与表达式无法区分，并且类型声明被解析为数组类型声明。若要解决歧义，请将约束嵌入接口中或使用尾随逗号：

```go
type T[P interface{*C}] …
type T[P *C,] …
```

类型参数也可以由与泛型类型关联的方法声明的接收方规范声明。

在泛型类型 `T` 的类型参数列表内，类型约束不能（直接地或通过另一泛型类型的类型参数列表间接地）引用 `T`。

```go
type T1[P T1[P]] …                    // illegal: T1 refers to itself
type T2[P interface{ T2[int] }] …     // illegal: T2 refers to itself
type T3[P interface{ m(T3[int])}] …   // illegal: T3 refers to itself
type T4[P T5[P]] …                    // illegal: T4 refers to T5 and
type T5[P T4[P]] …                    //          T5 refers to T4

type T6[P int] struct{ f *T6[P] }     // ok: reference to T6 is not in type parameter list
```

>---

#### 类型约束

类型约束是一个接口，它为相应的类型参数定义了一组允许的类型参数，并控制该类型参数的值所支持的操作。

```ABTLR
TypeConstraint = TypeElem 
```

如果约束是一个形式为 `interface{E}` 的接口文本，其中 `E` 是一个嵌入的类型元素（不是方法），在类型参数列表中，为了方便起见，可以省略封闭的 `interface{ … }`：

```go
[T []P]                      // = [T interface{[]P}]
[T ~int]                     // = [T interface{~int}]
[T int|string]               // = [T interface{int|string}]
type Constraint ~int         // illegal: ~int is not in a type parameter list
```

预先声明的接口类型 `comparable` 表示所有严格可比较的非接口类型的集合。尽管不是类型参数的接口是可比较的，但它们不是严格可比较的，因为它们不能实现 `comparable`，但是它们有满足 `comparable` 约束。

```go
int                          // implements comparable (int is strictly comparable)
[]byte                       // does not implement comparable (slices cannot be compared)
interface{}                  // does not implement comparable (see above)
interface{ ~int | ~string }  // type parameter only: implements comparable (int, string types are strictly comparable)
interface{ comparable }      // type parameter only: implements comparable (comparable implements itself)
interface{ ~int | ~[]byte }  // type parameter only: does not implement comparable (slices are not comparable)
interface{ ~struct{ any } }  // type parameter only: does not implement comparable (field any is not strictly comparable)
```

`comparable` 接口和（直接或间接）嵌入 `comparable` 的接口只能用作类型约束。它们不能是值或变量的类型，也不能是其他非接口类型的组件。

>---

#### 满足类型约束

如果类型参数 `T` 是由类型参数 `C` 定义的类型集合的元素，则类型参数 `T` 满足类型约束 `C`；即，如果 `T` 实现了 `C`。作为一个例外，一个严格可比较的类型约束也可以由一个可比较的（不一定是严格可比较的）类型参数来满足。更准确地说：
- `T` 实现 `C`；或
- `C` 可以写成 `interface{ comparable; E }` 的形式，其中 `E` 是一个基本接口，`T` 是可比较的，实现了 `E`。

```go
type argument      type constraint                // constraint satisfaction

int                interface{ ~int }              // satisfied: int implements interface{ ~int }
string             comparable                     // satisfied: string implements comparable (string is strictly comparable)
[]byte             comparable                     // not satisfied: slices are not comparable
any                interface{ comparable; int }   // not satisfied: any does not implement interface{ int }
any                comparable                     // satisfied: any is comparable and implements the basic interface any
struct{f any}      comparable                     // satisfied: struct{f any} is comparable and implements the basic interface any
any                interface{ comparable; m() }   // not satisfied: any does not implement the basic interface interface{ m() }
interface{ m() }   interface{ comparable; m() }   // satisfied: interface{ m() } is comparable and implements the basic interface interface{ m() }
```

由于约束满足规则中的异常，比较类型参数类型的操作数可能在运行时异常（即使可比较的类型参数总是严格可比较的）。

>---
#### 类型参数实例化

泛型函数或类型通过用类型实参替换类型形参来实例化。实例化分为两个步骤：
  1. 在泛型声明中，每个类型参数都替换为其对应的类型参数。这种替换发生在整个函数或类型声明中，包括类型参数列表本身和该列表中的任何类型。
  2. 在替换之后，每个类型参数必须满足相应类型参数的约束（必要时实例化）。否则实例化失败。

实例化类型会产生一个新的非泛型命名类型；实例化函数会产生一个新的非泛型函数。

```go
//type parameter list  type arguments   after substitution

[P any]                int               // int satisfies any
[S ~[]E, E any]        []int, int        // []int satisfies ~[]int, int satisfies any
[P io.Writer]          string            // illegal: string doesn't satisfy io.Writer
[P comparable]         any               // any satisfies (but does not implement) comparable
```

当使用泛型函数时，类型参数可以显式提供，或者它们可以部分或完全从使用该函数的上下文推断。如果可以推断，类型参数列表可以完全省略，如果函数是：
- 用普通的参数调用；
- 赋给已知类型的变量；
- 作为参数传递给另一个函数，或者；
- 作为结果返回。

在所有其他情况下，必须存在（可能是部分）类型参数列表。如果类型参数列表不存在或不完整，则所有缺失的类型参数必须可从使用该函数的上下文推断。

```go
// sum returns the sum (concatenation, for strings) of its arguments.
func sum[T ~int | ~float64 | ~string](x... T) T { … }

x := sum                       // illegal: the type of x is unknown
intSum := sum[int]             // intSum has type func(x... int) int
a := intSum(2, 3)              // a has value 5 of type int
b := sum[float64](2.0, 3)      // b has value 5.0 of type float64
c := sum(b, -1)                // c has value 4.0 of type float64

type sumFunc func(x... string) string
var f sumFunc = sum            // same as var f sumFunc = sum[string]
f = sum                        // same as f = sum[string]
```

部分类型参数列表不能为空；至少第一个参数必须存在。该列表是类型参数完整列表的前缀，其余参数将由推断得出。不严格地说，类型参数可以从 “右到左” 省略。

```go
unc apply[S ~[]E, E any](s S, f func(E) E) S { … }

f0 := apply[]                  // illegal: type argument list cannot be empty
f1 := apply[[]int]             // type argument for S explicitly provided, type argument for E inferred
f2 := apply[[]string, string]  // both type arguments explicitly provided

var bytes []byte
r := apply(bytes, func(byte) byte { … })  // both type arguments inferred from the function arguments
```

对于泛型类型，必须始终显式提供所有类型参数。

>---
#### 类型推断

如果可以从使用泛型函数的上下文（包括函数的类型参数的约束）推断出某些或所有类型参数，则可以省略这些类型参数。如果类型推断可以推断出缺少的类型参数，则类型推断成功，并且使用推断的类型参数实例化成功。否则，类型推断失败，程序无效。

类型推断使用类型对之间的类型关系进行推断：例如，函数实参必须可分配给其相应的函数形参；这建立了实参类型和形参类型之间的关系。如果这两个类型中的任何一个包含类型参数，则类型推断将查找要替换类型参数的类型参数，以便满足可赋值关系。类似地，类型推断使用类型参数必须满足其相应类型形参的约束这一事实。

每对匹配类型对应于一个类型方程，该方程包含一个或多个类型参数，来自一个或多个泛型函数。推断缺少的类型参数意味着求解相应类型参数的类型方程组。

```go
// dedup returns a copy of the argument slice with any duplicate entries removed.
func dedup[S ~[]E, E comparable](S) S { … }

type Slice []int
var s Slice
s = dedup(s)   // same as s = dedup[Slice, int](s)
```

类型 `Slice` 的变量 `s` 必须可分配给函数参数类型 `S`，以使程序有效。为了降低复杂性，类型推断忽略了赋值的方向性，因此 `Slice` 和 `S` 之间的类型关系可以通过（对称）类型方程 `Slice` $≡_A$ `S` （或 `S` $≡_A$ `Slice`）来表达，其中 $≡_A$ 中的 $_A$ 表示 *LHS* 和 *RHS* 类型必须根据可赋值规则匹配。类似地，类型参数 `S` 必须满足其约束 `~[]E`。这可以表示为 `S` $≡_C$ `~[]E`，其中 `X` $≡_C$ `Y` 代表 “`X` 满足约束 `Y`”。这些观察结果导致了一组两个方程

<pre>
	Slice ≡<sub>A</sub>  S      (1)
	S     ≡<sub>C</sub>  <code>~[]E</code>   (2)
</pre>

现在可以针对类型参数 `S` 和 `E` 求解该问题。从（1）编译器可以推断出 `S` 的类型参数是 `Slice`。类似地，因为 `Slice` 的底层类型是 `[]int`，并且 `[]int` 必须匹配约束的 `[]E`，所以编译器可以推断出 `E` 必须是 `int`。因此，对于这两个等式，类型推断推断

<pre><code>
	S ➞ Slice
	E ➞ int
</code></pre>

给定一组类型方程，要求解的类型参数是需要实例化的函数的类型参数，并且没有为其提供显式类型参数。这些类型参数称为绑定类型参数。例如，在上面的 `dedup` 示例中，类型参数 `S` 和 `E` 被绑定到 `dedup`。泛型函数调用的参数可以是泛型函数本身。该函数的类型参数包含在绑定类型参数集中。函数参数的类型可能包含来自其他函数的类型参数（例如包含函数调用的泛型函数）。这些类型参数也可能出现在类型表达式中，但它们不受该上下文中的约束。类型方程总是只针对绑定的类型参数求解。

类型推断支持调用泛型函数和将泛型函数赋值给（显式函数类型的）变量。这包括将泛型函数作为参数传递给其他（可能也是泛型）函数，并将泛型函数作为结果返回。类型推断对特定于每种情况的一组方程进行操作。方程如下：
- 对于函数调用 `f(a0,a1,...)`，其中函数参数 `ai` 是泛型函数：
  - 每对对应的函数实参和形参 `(ai, pi)` ，其中 `ai` 不是无类型常量，产生等式 `typeof(pi)` $≡_A$ `typeof(ai)`。
  - 如果 `ai` 是一个无类型的常量 `cj`，而 `typeof(pi)` 是一个绑定类型参数 `Pk`，则从类型方程中单独收集对 `(cj, Pk)`。
- 对于泛型函数 `f` 到函数类型的（非泛型）变量 `v` 的赋值 `v = f`：`typeof(v)` $≡_A$ `typeof(f)`。
- 对于返回语句 `return …, f, …`，其中 `f` 是作为结果返回到函数类型的（非泛型）结果变量 `r` 的泛型函数：`typeof(r)` $≡_A$ `typeof(f)`。

另外，每个类型参数 `Pk` 和对应的类型约束 `Ck` 产生类型等式 `Pk` $≡_C$ `Ck`。

在考虑非类型化常量之前，类型推断优先考虑从类型化操作数获得的类型信息。因此，推理过程分为两个阶段：
  1. 使用类型统一的类型方程求解的绑定类型参数。如果统一失败，则类型推理失败。
  2. 对于每个绑定类型参数 `Pk`，其类型参数尚未被推断，并且其具有相同类型参数的一个或多个对 `(cj, Pk)` 被收集，以与常量表达式相同的方式确定所有这些对中的常量 `cj` 的常量种类。`Pk` 的类型参数是确定的常量类型的默认类型。如果由于常量种类冲突而无法确定常量种类，则类型推断失败。

如果在这两个阶段之后没有找到所有类型参数，则类型推断失败。如果这两个阶段都成功了，类型推断会为每个绑定的类型参数确定一个类型参数：`Pk` ➞ `Ak`。

类型参数 `Ak` 可以是复合类型，包含其他绑定类型参数 `Pk` 作为元素类型（甚至只是另一个绑定类型参数）。在重复简化的过程中，每个类型参数中的绑定类型参数被这些类型参数的相应类型参数替换，直到每个类型参数没有绑定类型参数。

如果类型参数包含通过绑定类型参数对其自身的循环引用，则简化和类型推断将失败。否则，类型推断成功。

>---

#### 类型统一

类型推断通过类型统一来解决类型方程。类型统一递归地比较等式的 LHS 和 RHS 类型，其中任一或两个类型可以是或包含绑定类型参数，并查找这些类型参数的类型参数，使得 LHS 和 RHS 匹配（取决于上下文，变得相同或赋值兼容）。为此，类型推断维护了绑定类型参数到推断类型参数的映射；在类型统一期间会查询和更新此映射。最初，绑定类型参数是已知的，但映射是空的。在类型统一期间，如果推断出新的类型参数 `A`，则从类型参数到参数的相应映射 `P` ➞ `A` 被添加到映射。相反，在比较类型时，已知类型参数（已存在映射项的类型参数）将代替其对应的类型参数。 随着类型推断的进行，映射被越来越多地填充，直到所有方程都被考虑，或者直到统一失败。如果没有统一步骤失败，并且映射对每个类型参数都有一个条目，则类型推断成功。

例如，给定具有绑定类型参数 `P` 的类型方程：`[10]struct{ elem P, list []P }` $≡_A$ `[10]struct{ elem string; list []string }`。

类型推断从空映射开始。统一首先比较了 LHS 和 RHS 类型的顶层结构。两者都是长度相同的数组；如果元素类型统一，则它们统一。两种元素类型都是结构；如果它们具有相同名称的相同数量的字段，并且字段类型统一，则它们统一。`P` 的类型参数还不知道（没有映射项），所以将 `P` 和 `string` 统一起来会将映射 `P` ➞ `string` 添加到映射中。统一 `list` 字段的类型需要统一 `[]P` 和 `[]string`，从而统一 `P` 和 `string`。由于此时已知 `P` 的类型参数（有一个映射条目用于 `P`），因此其类型参数 `string` 将取代 `P`。由于 `string` 与 `string` 相同，因此该统一步骤也成功。方程的 LHS 和 RHS 的统一现在完成了。类型推断成功，因为只有一个类型等式，没有统一步骤失败，并且映射被完全填充。

统一使用精确统一和松散统一的组合，这取决于两个类型是否等价、分配兼容、或仅在结构上相等。

对于形式为 `X` $≡_A$ `Y` 的等式，其中 `X` 和 `Y` 是赋值中涉及的类型（包括参数传递和返回语句），顶级类型结构可以松散地统一，但元素类型必须完全统一，以匹配赋值规则。

对于形式为 `P` $≡_C$ `C` 的方程，其中 `P` 是类型参数，`C` 是其对应的约束，统一规则稍微复杂一些：
- 如果 `C` 有一个核心类型 `core(C)`，而 `P` 有一个已知类型参数 `A`，那么 `core(C)` 和 `A` 必须松散地统一。如果 `P` 没有已知的类型参数，并且 `C` 只包含一个不是底层（波浪号）类型的类型项 `T`，则统一将映射 `P` ➞ `T` 添加到映射中。
- 如果 `C` 没有核心类型，而 `P` 有一个已知的类型参数 `A`，那么 `A` 必须有 `C` 的所有方法（如果有的话），并且对应的方法类型必须完全统一。

当从类型约束求解类型方程时，求解一个方程可以推断出附加的类型参数，这反过来又可以求解依赖于这些类型参数的其他方程。只要推断出新的类型参数，类型推断就会重复类型统一。

>---

#### 类型统一规则

类型统一规则描述了两个类型是否统一以及如何统一。精确的细节与 Go 实现相关，影响错误消息的细节（例如编译器是否报告类型推断或其他错误），并可能解释为什么类型推断在异常代码情况下失败。但是，在编写 Go 代码时，这些规则基本上可以忽略：类型推断被设计为大多数情况下 “按预期工作”，统一规则也相应地进行了微调。

类型统一由匹配模式控制，可以是精确的，也可以是松散的。由于统一递归地下降到复合类型结构，用于类型元素的匹配模式，元素匹配模式，保持与匹配模式相同，除非两个类型为可分配性而统一（ $≡_A$ ）：在这种情况下，匹配模式在顶层是松散的，但随后对于元素类型更改为精确的，反映了类型不必相同即可分配的事实。

如果以下任一条件为真，则两个不是绑定类型参数的类型完全统一：
- 这两种类型是相同的。
- 这两种类型具有相同的结构，它们的元素类型完全统一。
- 只有一个类型是具有核心类型的未绑定类型参数，并且该核心类型根据 $≡_A$ 的统一规则与另一个类型统一（顶层的松散统一和元素类型的精确统一）。

如果两个类型都是绑定类型参数，则它们根据给定的匹配模式统一，如果：
- 两个类型参数是相同的。
- 最多有一个类型参数具有已知的类型参数。在这种情况下，类型参数被连接：它们都代表相同的类型参数。如果两个类型参数都没有已知的类型参数，则为其中一个类型参数推断的未来类型参数同时为它们两者推断。
- 两个类型参数都有一个已知的类型参数，并且类型参数根据给定的匹配模式统一。

单个绑定类型参数 `P` 和另一个类型 `T` 根据给定的匹配模式统一，如果：
- `P` 没有已知类型参数。在这种情况下，`T` 被推断为 `P` 的类型参数。
- `P` 确实有一个已知的类型参数 `A`、`A` 和 `T` 根据给定的匹配模式统一，并且以下条件之一为真：
  - `A` 和 `T` 都是接口类型：在这种情况下，如果 `A` 和 `T` 也是定义的类型，则它们必须相同。否则，如果它们都不是已定义类型，则它们必须具有相同数量的方法（`A` 和 `T` 的统一已经建立了方法匹配）。
  - `A` 和 `T` 都不是接口类型：在这种情况下，如果 `T` 是一个定义的类型，`T` 将取代 `A` 作为 `P` 的推断类型参数。

最后，两个不是绑定类型参数的类型松散地统一（并且根据元素匹配模式），如果：
- 这两种类型完全统一。
- 一种类型是定义的类型，另一种类型是类型文本，但不是接口，它们的基础类型根据元素匹配模式统一。
- 这两种类型都是具有相同类型项的接口（但不是类型参数），两者或两者都不嵌入预先声明的 `comparable` 类型，对应的方法类型完全统一，并且其中一个接口的方法集是另一个接口的方法集的子集。
- 只有一种类型是接口（但不是类型参数），两种类型的对应方法根据元素匹配模式统一，并且接口的方法集是另一种类型的方法集的子集。
- 这两种类型具有相同的结构，并且它们的元素类型根据元素匹配模式统一。

---
### 内置函数

内置函数是预先声明的。它们可以像其他函数一样被调用，但其中一些函数接受类型而不是表达式作为第一个参数。内置函数没有标准的 Go 类型，因此它们只能出现在调用表达式中；它们不能用作函数值。

>--- 
#### append：切片扩展

```go
func append(slice []Type, elems ...Type) []Type // core type of slice is []Type
```

可变参数函数 `append` 将零个或多个值 `elems` 附加到切片 `slice`，并返回与 `slice` 相同类型的结果切片。`slice` 的核心类型必须是 `[]Type` 类型的切片。值 `elems` 被传递给类型 `...Type` 的参数，并且应用相应的参数传递规则。作为特殊情况，如果 `slice` 的核心类型是 `[]byte`，则 `append` 也接受核心类型为 `bytestring` 后跟 `...` 的第二个参数。这种形式追加字节切片或字符串的字节。结果与参数引用的内存是否重叠无关。

```go
func append(slice []Byte, str ...string) []Byte
```

如果 `slice` 的容量不足以容纳额外的值，`append` 会分配一个新的、足够大的底层数组（长度为原切片最大容量的二倍），以容纳现有的切片元素和额外的值。否则，在切片有效容量内，`append` 会重用底层数组，扩容切片也可能会修改底层数组的元素值。

```go
s0 := []int{0, 0}
s1 := append(s0, 2)                // append a single element     s1 is []int{0, 0, 2}
s2 := append(s1, 3, 5, 7)          // append multiple elements    s2 is []int{0, 0, 2, 3, 5, 7}
s3 := append(s2, s0...)            // append a slice              s3 is []int{0, 0, 2, 3, 5, 7, 0, 0}
s4 := append(s3[3:6], s3[2:]...)   // append overlapping slice    s4 is []int{3, 5, 7, 2, 3, 5, 7, 0, 0}

var t []interface{}
t = append(t, 42, 3.1415, "foo")   //                             t is []interface{}{42, 3.1415, "foo"}

var b []byte
b = append(b, "bar"...)            // append string contents      b is []byte{'b', 'a', 'r' }
```

>---
#### copy：切片复制

```go
func copy(dst, src []Type) int
```

函数 `copy` 将切片元素从源 `src` 复制到 `dst`，并返回所复制的元素的数目。两个参数的核心类型必须是具有相同元素类型的切片。复制的元素数为 `len(src)` 和 `len(dst)` 的最小值。作为特殊情况，如果目标的核心类型是 `[]byte`，则 `copy` 也接受核心类型为 `bytestring` 的源参数。这种形式将字节从字节切片或字符串复制到字节切片中。结果与参数引用的内存是否重叠无关。

```go
copy(dst []byte, src string) int
```
```go
var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
var b = make([]byte, 5)
n1 := copy(s, a[0:])            // n1 == 6, s is []int{0, 1, 2, 3, 4, 5}
n2 := copy(s, s[2:])            // n2 == 4, s is []int{2, 3, 4, 5, 4, 5}
n3 := copy(b, "Hello, World!")  // n3 == 5, b is []byte("Hello")
```

>---
#### clear：清零或删除元素

```go
func clear[T ~[]Type | ~map[Type]Type1](t T)
```

内置函数 `clear` 接受 `map`、`slice` 或 `type parameter` 类型的参数，并删除或清零所有元素。

```go
Call        Argument type     Result

clear(m)    map[K]T           deletes all entries, resulting in an empty map (len(m) == 0)

clear(s)    []T               sets all elements up to the length of
                              s to the zero value of T

clear(t)    type parameter    see below
```

如果 `clear` 的参数类型是类型参数，则其类型集中的所有类型都必须是映射或切片，而 `clear` 执行与实际类型参数对应的操作。如果 `map` 或 `slice` 为 `nil`，则 `clear` 为无操作。

>---
#### close：关闭通道

```go
func close(c chan<- Type)
```

对于核心类型为通道的参数 `ch`，内置函数 `close` 记录不会在通道上发送更多值。如果 `ch` 是仅接收通道，则发生错误。发送或关闭已关闭的通道会导致运行时异常。关闭 `nil` 通道也会导致运行时异常。

在调用 `close` 之后，并且在接收到任何先前发送的值之后，接收操作将返回通道类型的零值，而不会阻塞。多值接收操作返回接收值以及通道是否关闭的指示。

>---
#### complex、real、imag：复数操作

```go
func complex(r, i FloatType) ComplexType
func real(c ComplexType) FloatType
func imag(c ComplexType) FloatType
```

内置函数 `complex` 从浮点实部和虚部构造一个复数值，而 `real` 和 `imag` 提取复数值的实部和虚部。

参数的类型与返回值相对应。对于 `complex`，两个参数必须是具有相同浮点类型，且返回类型也是具有相应浮点类型的复数类型：`float32` 类型的参数对应 `complex64` 的返回类型，`float64` 类型的参数对应于 `complex128` 的返回类型。如果其中一个参数的计算结果是无类线常量，则首先将其隐式转换为另一个参数的类型。若两个参数都是无类型常量，则它们必须是非复数，或者它们的虚部必须为零，并且函数的返回值是无类型的复常量。

对于 `real` 和 `imag`，参数必须是复数类型，并且返回类型是对应的浮点类型：对于 `complex64` 参数，返回类型是 `float32`，对于 `complex128` 参数，返回类型是 `float64`。如果参数计算为无类型常数，则它必须是数字，并且函数的返回值是无类型浮点常数。

对于复数类型 `Z` 的值 `z`，`z == Z(complex(real(z), imag(z)))`。

如果这些函数的操作数都是常量，则返回值是常量。不允许参数类型的参数。

```go
var a = complex(2, -2)             // complex128
const b = complex(1.0, -1.4)       // untyped complex constant 1 - 1.4i
x := float32(math.Cos(math.Pi/2))  // float32
var c64 = complex(5, -x)           // complex64
var s int = complex(1, 0)          // untyped complex constant 1 + 0i can be converted to int
_ = complex(1, 2<<s)               // illegal: 2 assumes floating-point type, cannot shift
var rl = real(c64)                 // float32
var im = imag(a)                   // float64
const c = imag(b)                  // untyped constant -1.4
_ = imag(3 << s)                   // illegal: 3 assumes complex type, cannot shift
```

>--- 
#### delete：删除映射元素

```go
func delete(m map[Type]Type1, key Type)
```

内置函数 `delete` 从映射 `m` 中删除键为 `key` 的元素。`key` 的值必须可分配给 `m` 的键类型
 
如果 `m` 的类型是类型参数，则该类型集中的所有类型都必须是映射，并且它们必须具有相同的键类型。如果映射 `m` 是 `nil` 或元素 `m[key]` 不存在，则 `delete` 是空操作。

```go
var m = map[int]string{
	0: "zero",
	1: "one",
	2: "two",
	3: "three",
	4: "four",
}
delete(m, 0)
for _, v := range m {
	print(v + ",")  // one,two,three,four,
}
```

>---
#### len、cap：长度与容量

```go
func len(v Type) int
func cap(v Type) int
```

内置函数 `len` 和 `cap` 接受数组、指向数组的指针、切片、映射、字符串、通道类型的参数，并返回类型为 `int` 的结果。该实现保证结果始终是一个 `int`。

```go
Call      Argument type    Result

len(s)    string type      string length in bytes
          [n]T, *[n]T      array length (== n)
          []T              slice length
          map[K]T          map length (number of defined keys)
          chan T           number of elements queued in channel buffer
          type parameter   see below

cap(s)    [n]T, *[n]T      array length (== n)
          []T              slice capacity
          chan T           channel buffer capacity
          type parameter   see below
```

如果参数类型是类型参数 `P`，则调用 `len(e)`（或 `cap(e)`）必须对 `P` 的类型集中的每个类型有效。结果是参数的长度（或容量），其类型对应于实例化 `P` 的类型参数。

切片的容量是底层数组中为其分配空间的元素的数量。在任何时候，以下关系成立：

```go
0 <= len(s) <= cap(s)
```

`nil` 切片、映射或通道的长度为 0。`nil` 切片或通道的容量为 0。

如果 `s` 是字符串常量，则表达式 `len(s)` 是常量。如果表达式 `s` 的类型是数组或指向数组的指针，并且表达式 `s` 不包含通道接收或（非常量）函数调用，则表达式 `len(s)` 和 `cap(s)` 是常量；在这种情况下，不计算 `s`。否则，对 `len` 和 `cap` 的调用不是常量，而 `s` 被求值。

```go
const (
	c1 = imag(2i)                    // imag(2i) = 2.0 is a constant
	c2 = len([10]float64{2})         // [10]float64{2} contains no function calls
	c3 = len([10]float64{c1})        // [10]float64{c1} contains no function calls
	c4 = len([10]float64{imag(2i)})  // imag(2i) is a constant and no function call is issued
	c5 = len([10]float64{imag(z)})   // invalid: imag(z) is a (non-constant) function call
)
var z complex128
```

>---
#### make：分配

```go
func make(t Type, size ...IntegerType) Type
```

内置函数 `make` 接受类型 `Type`，可选地后跟特定类型的表达式列表。`Type` 的核心类型必须是切片、应映射、通道。它的返回类型为 `Type`（不是 `Type *`）。结果取决于参数的类型。

```go
Call             Core type    Result

make(T, n)       slice        // slice of type T with length n and capacity n
make(T, n, m)    slice        // slice of type T with length n and capacity m

make(T)          map          // map of type T
make(T, n)       map          // map of type T with initial space for approximately n elements

make(T)          channel      // unbuffered channel of type T
make(T, n)       channel      // buffered channel of type T, buffer size n
```

每个大小参数 `n` 和 `m` 必须是整数类型，具有仅包含整数类型的类型集，或者是无类型的常量。常量大小参数必须是非负的，并且可以用类型 `int` 的值表示；如果它是一个无类型的常量，则给出类型 `int`。如果 `n` 和 `m` 都被提供并且是常量，则 `n` 必须不大于 `m`。对于切片和通道，如果运行时 `n` 为负或大于 `m`，则会发生运行时异常。

```go
s := make([]int, 10, 100)       // slice with len(s) == 10, cap(s) == 100
s := make([]int, 1e3)           // slice with len(s) == cap(s) == 1000
s := make([]int, 1<<63)         // illegal: len(s) is not representable by a value of type int
s := make([]int, 10, 0)         // illegal: len(s) > cap(s)
c := make(chan int, 10)         // channel with a buffer size of 10
m := make(map[string]int, 100)  // map with initial space for approximately 100 elements
```

使用 `map` 类型和 `size` 作为参数调用 `make` 将创建一个带有初始内存空间的映射，以容纳 `size` 个映射元素。具体的行为取决于实现。

`make([]int, 10, 100)` 分配一个容纳 100 个 `int` 的数组，然后创建一个长度为 10、容量为 100 的切片结构，指向数组的前 10 个元素。`make` 构造切片时，容量可以省略；相反，`new([]int)` 返回一个指向新分配的零切片结构的指针，即指向 `nil` 切片值的指针。

以下说明了 `new` 和 `make` 之间的区别。

```go
var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100)
```

>---
#### min、max：最大值和最小值

```go
func min[T cmp.Ordered](x T, y ...T) T
func max[T cmp.Ordered](x T, y ...T) T
```

内置函数 `min` 和 `max` 分别计算固定数量的有序类型参数的最小值或最大值。必须至少有一个参数。

与运算符相同的类型规则适用于：对于有序参数 `x` 和 `y`，如果 `x + y` 有效，则 `min(x, y)` 有效，并且 `min(x, y)` 的类型是 `x + y` 的类型（对于 `max` 也是如此）。如果所有参数都是常量，则结果也是常量。

```go
var x, y int
m := min(x)                 // m == x
m := min(x, y)              // m is the smaller of x and y
m := max(x, y, 10)          // m is the larger of x and y but at least 10
c := max(1, 2.0, 10)        // c == 10.0 (floating-point kind)
f := max(0, float32(x))     // type of f is float32
var s []string
_ = min(s...)               // invalid: slice arguments are not permitted
t := max("", "foo", "bar")  // t == "foo" (string kind)
```

对于数值类型参数，假设所有的 NaN 相等，则 `min` 和 `max` 是可交换且可结合的：

```go
min(x, y)    == min(y, x)
min(x, y, z) == min(min(x, y), z) == min(x, min(y, z))
```

对于浮点参数负零、NaN 和无穷大，以下规则适用：

```go
   x        y    min(x, y)    max(x, y)

  -0.0    0.0         -0.0          0.0    // negative zero is smaller than (non-negative) zero
  -Inf      y         -Inf            y    // negative infinity is smaller than any other number
  +Inf      y            y         +Inf    // positive infinity is larger than any other number
   NaN      y          NaN          NaN    // if any argument is a NaN, the result is a NaN
```

对于字符串参数，`min` 的结果是第一个具有最小值的参数（或 `max`，最大值），按字节进行词法比较：

```go
min(x, y)    == if x <= y then x else y
min(x, y, z) == min(min(x, y), z)
```

>---
#### new：分配

```go
func new(Type) *Type
```

内置函数 `new(T)` 为类型为 `T` 的新项分配归零的存储空间，并返回其地址，类型为 `*T` 的值。

```go
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
```

为类型 `SyncedBuffer` 的变量分配存储空间，并返回一个指向新分配零值位置的地址 `*SyncedBuffer` 的值。

类型 `SyncedBuffer` 的值也可以在分配或声明时立即使用。例如，`p` 和 `v` 都将正确工作，无需进一步操作。

```go
p := new(SyncedBuffer)  // type *SyncedBuffer
var v SyncedBuffer      // type  SyncedBuffer
```

>---
#### panic、recover：异常处理

```go
func panic(v any)
func recover() any
```

内置函数 `panic` 和 `recover` 有助于报告和处理运行时异常和程序定义的错误条件。

在执行函数 `F` 时，对 `panic` 的显式调用或运行时 `panic` 会终止 `F` 的执行。任何被 `F` 延迟的函数都会照常执行。然后由 `F` 返回它的调用方。对于调用方 `G`，调用 F 的行为就像调用 panic，终止 G 的执行并运行任何延迟的函数。依此类推，直到执行至 *goroutine* 中的顶级函数延迟。此时，程序终止并报告错误条件，并包括 `panic` 的参数值。这种终止序列被称为 *panicking*。

```go
panic(42)
panic("unreachable")
panic(Error("cannot parse"))
```

`recover` 函数允许程序管理一个 *panicking* *goroutine* 的行为。假设一个函数 `G` 推迟了一个调用 `recover` 的函数 `D`，并且在 `D` 执行的同一个 *goroutine* 上的一个函数中发生了一个 `panic`。当延迟函数的运行到达 `D` 时，`D` 调用 `recover` 的返回值将是传递给 `panic` 调用的值。如果 `D` 正常返回，而没有启动新的 `panic`，则 *panicking* 序列停止。在这种情况下，在 `G` 和调用 `panic` 之间调用的函数的状态被丢弃，并且恢复正常执行。然后运行任何在 `D` 之前被 `G` 延迟的函数，并且 `G` 的执行将通过返回到其调用者而终止。

当 *goroutine* 没有出现 *panicking* 或者 `recover` 没有被延迟函数直接调用时，`recover` 的返回值是 `nil`。相反，如果一个 *goroutine* 出现了 *panicking*，并且 `recover` 被一个延迟函数直接调用，那么 `recover` 的返回值肯定不会是 `nil`。因此，如果使用 `nil` 接口值（或非类型化的 `nil`）调用 `panic` 会导致运行时异常。

下面示例中的 `protect` 函数调用函数参数 `g`，并保护调用方免受 `g` 引发的运行时异常。

```go
func main() {
	protect(func() {
		var a, b int = 1, 0
		_ = a / b
	})
}
func protect(g func()) {
	defer func() {
		log.Println("done") // Println executes normally even if there is a panic
		if x := recover(); x != nil {
			log.Printf("run time panic: %v", x)
		}
	}()
	log.Println("start")
	g()
}
```

>---
#### print、println：格式化输出

```go
func print(args ...Type)
func println(args ...Type)
```

当前的实现提供了几个在引导过程有用的内置函数。这些函数是为了完整性而记录的，但不能保证保持在语言中。它们不返回结果。

```go
Function   Behavior

print      prints all arguments; formatting of arguments is implementation-specific
println    like print but prints spaces between arguments and a newline at the end
```

`print` 内置函数以特定于实现的方式格式化其参数，并将结果写入标准错误。`print` 对于引导和调试很有用；它不能保证留在语言中。

`println` 内置函数以特定于实现的方式格式化其参数，并将结果写入标准错误。参数之间总是添加空格，并附加换行符。`println` 对于引导和调试很有用；它不能保证留在语言中。

实现限制：`print` 和 `println` 不需要接受任意参数类型，但必须支持布尔、数值和字符串类型的打印。

---
### Error 与 Run-time Panic

库例程必须经常向调用者返回某种错误指示。Go 语言的多值返回使得在返回正常返回值的同时返回详细的错误描述变得很容易。例如，`os.Open` 在失败时不仅返回一个 `nil` 指针，它还返回一个描述错误的错误值。

错误类型为 `error`，这是一个简单的内置接口。

```go
type error interface {
	Error() string
}
```

预先声明的类型 `error` 表示错误条件的常规接口，`nil` 值表示没有错误。例如，可以定义一个从文件中读取数据的函数：

```go
func Read(f* File, b []byte) (n int, err error)
```

在可行的情况下，错误字符串应该标识它们的来源，例如通过使用一个前缀来命名生成错误的操作或包。例如，在包 `image` 中，由于未知格式导致的解码错误的字符串表示是 “`image：unknown format`”。关心精确错误细节的调用方可以使用 *TypeSwitch* 或类型断言来查找特定错误并提取细节。

```go
for try := 0; try < 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
	// 类型断言
    if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Recover some space.
        continue
    }
    return
}
```

执行错误（如试图将数组索引到边界之外）会触发一个运行时异常，相当于使用实现定义的接口类型 `runtime.Error` 的值调用内置函数 `panic`。该类型满足预先声明的接口类型 `error`。未指定表示不同运行时错误条件的确切错误值。

```go
package runtime

type Error interface{
	error
	// and perhaps other methods
}
```

函数通常在最后的返回值中返回错误信息。使用 `errors.New` 可返回一个错误信息：

```go
func Sqrt(f float64) (float64, error) {
    if f < 0 {
        return 0, errors.New("math: square root of negative number")
    }
    // ...
}
```

调用 `Sqrt` 的时候传递的一个负数，然后就得到了 `non-nil` 的 `error` 对象，将此对象与 `nil` 比较，结果为 `true`，`fmt.Println` 函数在处理 `error` 时会调用 `Error` 方法，以输出错误信息：

```go
result, err:= Sqrt(-1)
if err != nil {
   fmt.Println(err)  // math: square root of negative number
}
```

>---
#### Panic

向调用方报告错误的常用方法是返回一个 `error` 作为额外的返回值。规范的 `Read` 方法是一个众所周知的实例：它返回一个字节计数和一个 `error`。但如果错误是不可恢复的呢？有时候，程序根本无法继续。

因此，有一个内置函数 `panic`，它实际上会创建一个运行时错误，从而停止程序。该函数接受一个任意类型的参数（通常是一个字符串），并在程序结束时打印出来。这也是一种表示不可能发生的事情的方式，例如退出无限循环。

```go
// A toy implementation of cube root using Newton's method.
func CubeRoot(x float64) float64 {
    z := x/3   // Arbitrary initial value
    for i := 0; i < 1e6; i++ {
        prevz := z
        z -= (z*z*z-x) / (3*z*z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // A million iterations has not converged; something is wrong.
    panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
```

真实的库函数应该避免 `panic`。一个可能的反例是在初始化过程中：如果库真的无法设置自己，那么 `panic` 是合理的。

```go
var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("no value for $USER")
    }
}
```

>---
#### Recover

当 `panic` 被调用时，包括隐式的运行时错误，比如索引一个切片越界或类型断言失败，它会立即停止执行当前函数，并开始展开 *goroutine* 的堆栈，同时运行任何延迟的函数。如果展开到达了 *goroutine* 堆栈的顶部，程序就会终止。但是，可以使用内置函数 `recover` 重新获得对 *goroutine* 的控制并恢复正常执行。

对 `recover` 的调用会停止展开并返回传递给 `panic` 的参数。因为在展开时运行的唯一代码是在延迟函数中，所以 `recover` 只在延迟函数中有用。

```go
func server(workChan <-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
```

在这个例子中，如果 `do(work)` 出现异常，结果将被记录，*goroutine* 将干净地退出，而不会干扰其他程序。在延迟闭包中不需要做任何其他事情；调用 `recover` 可以完全处理这种情况。

除非从延迟函数直接调用，否则 `recover` 总是返回 `nil`，所以延迟代码可以调用库例程，这些库例程本身使用 `panic` 和 `recover` 因而不会失败。例如，`safelyDo` 中的延迟函数可能会在调用 `recover` 之前调用日志记录函数，并且日志记录代码将不受 *panicking* 状态的影响而运行。

有了 `recover` 模式，`do` 函数（以及它调用的任何东西）都可以通过调用 `panic` 来干净地摆脱任何糟糕的情况。可以用这个想法来简化复杂软件中的错误处理，例如一个理想化的 `regexp` 包，它通过使用本地 `Error` 类型调用 `panic` 来报告解析错误。下面是 `Error` 的定义、`error` 方法和 `Compile` 函数。

```go
// Error is the type of a parse error; it satisfies the error interface.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error is a method of *Regexp that reports parsing errors by
// panicking with an Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile returns a parsed representation of the regular expression.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse will panic if there is a parse error.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Clear return value.
            err = e.(Error) // Will re-panic if not a parse error.
        }
    }()
    return regexp.doParse(str), nil
}
```

>---
#### 自定义 Error

可以在编码中通过实现 `error` 接口类型自定义实现错误处理程序。

```go
type errno struct {
	code    int
	message string
}

var (
	errFormat string = `
	Error code = %d
	Message >>>> %s
`
	GO_ERR_001 = errno{1, "TMP_GO_ERR_001"}
	GO_ERR_002 = errno{2, "TMP_GO_ERR_002"}
	GO_ERR_003 = errno{3, "TMP_GO_ERR_003"}
	GO_ERR_004 = errno{4, "TMP_GO_ERR_004"}
)
// 实现 error 接口
func (e errno) Error() string {   
	return fmt.Sprintf(errFormat, e.code, e.message)
}

func Test(b bool) (e error) {
	if !b {
		e = GO_ERR_001
	}
	return
}

func main() {
	err := Test(false)
	if err != nil {
		fmt.Print(err)
	}
/*
        Error code = 1
        Message >>>> TMP_GO_ERR_001
*/
}

```

---