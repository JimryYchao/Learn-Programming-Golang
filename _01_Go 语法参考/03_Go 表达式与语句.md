## Go 表达式与语句

---
### 表达式

表达式通过对操作数应用运算符和函数来指定值的计算。

>---
#### 操作数

操作数表示表达式中的基本值。一个操作数可以是一个文本，一个（可能是限定的）表示一个常量、变量或函数的非空标识符，或者一个带括号的表达式。

```ANTLR
Operand     = Literal | OperandName [ TypeArgs ] | "(" Expression ")" 
Literal     = BasicLit | CompositeLit | FunctionLit 
BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit 
OperandName = identifier | QualifiedIdent 
```

表示泛型函数的操作数名称后面可以跟一个类型参数列表；生成的操作数是一个实例化函数。

空标识符只能作为操作数出现在赋值语句的左侧。

实现限制：如果一个操作数的类型是一个空类型集的类型参数，编译器不需要报告错误。具有此类类型参数的函数不能被实例化；任何尝试都将导致实例化点出错。

>---
#### 主表达式

主表达式可以是一元和二元表达式的操作数。

```ANTLR
PrimaryExpr =
	Operand |                           
	Conversion |
	MethodExpr |
	PrimaryExpr Selector |
	PrimaryExpr Index |
	PrimaryExpr Slice |
	PrimaryExpr TypeAssertion |
	PrimaryExpr Arguments 

Selector       = "." identifier 
Index          = "[" Expression [ "," ] "]" 
Slice          = "[" [ Expression ] ":" [ Expression ] "]" |
                 "[" [ Expression ] ":" Expression ":" Expression "]" 
TypeAssertion  = "." "(" Type ")" 
Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" 
```
```go
x
2
(s + ".txt")
f(3.1415, true)
Point{1, 2}
m["foo"]
s[i : j + 1]
obj.color
f.p[i].x()
```

>---
#### 索引表达式

索引表达式的主要形式为 `a[x]`，表示为以 `x` 为索引的数组、数组指针、切片、字符串或映射的元素。值 `x` 分别称为索引或映射键。以下规则适用：
- 如果 `a` 既不是 `map` 也不是类型参数：
  - 索引 `x` 必须是无类型常量或其核心类型必须是整数类型。
  - 常量索引必须是非负的，并且可由类型 `int` 的值表示。
  - 非类型化的常量索引被赋予类型 `int`。
  - 如果 `0 <= x < len(a)`，则索引 `x` 在范围内，否则它在范围外。
+ 对于数组类型 `A` 的 `a`：
  - 常量索引必须在范围内。
  - 如果 `x` 在运行时超出范围，则会发生运行时异常。
  - `a[x]` 是索引 `x` 处的数组元素，`a[x]` 的类型是 `A` 的元素类型。

- 对于指向数组类型的指针：
  - `a[x]` 是 `(*a)[x]` 的简写

+ 对于切片类型 `S` 的 `a`：
  - 如果 `x` 在运行时超出范围，则会发生运行时异常。
  - `a[x]` 是索引 `x` 处的切片元素，并且 `a[x]` 的类型是 `S` 的元素类型。

- 对于字符串类型的 `a`：
  - 如果字符串 `a` 也是常量，则常量索引必须在范围内。
  - 如果 `x` 在运行时超出范围，则会发生运行时异常。
  - `a[x]` 是索引 `x` 处的非常量字节值，`a[x]` 的类型是 `byte`。
  - `a[x]` 不能赋值（字符串不能修改）。

+ 对于映射类型 `M` 的 `a`：
  + `x` 的类型必须可分配给 `M` 的键类型。
  + 如果映射包含键为 `x` 的项，则 `a[x]` 是键为 `x` 的映射元素，而 `a[x]` 的类型是 `M` 的元素类型。
  + 如果映射是 `nil` 或不包含这样的项，则 `a[x]` 是元素类型 `M` 的零值。

- 对于类型参数类型 `P` 的 `a`：
  - 索引表达式 `a[x]` 必须对 `P` 的类型集中的所有类型的值有效。
  - `P` 的类型集中所有类型的元素类型必须相同。在这个上下文中，字符串类型的元素类型是 `byte`。
  - 如果在 `P` 的类型集中存在映射类型，则该类型集中的所有类型必须是映射类型，并且各个键类型必须全部相同。
  - `a[x]` 是索引 `x` 处的数组、切片或字符串元素，或者是具有用于实例化 `P` 的类型参数的键 `x` 的映射元素，而 `a[x]` 的类型是（相同的）元素类型的类型。
  - 如果 P 的类型集包括字符串类型，则 `a[x]` 不能赋值。

+ 否则 `a[x]` 是非法的。

类型为 `map[K]V` 的映射 `a` 上的索引表达式，用于赋值语句或特殊形式的初始化，例如 `v, ok = a[x]`、`v, ok := a[x]` or `var v, ok = a[x]`，表达式 `a[x]` 产生一个额外的无类型布尔值。如果键 `x` 存在于映射中，则 `ok` 的值为 `true`，否则为 `false`。

对值为 `nil` 的映射的元素执行错误操作会导致运行时异常。

>---
#### 类型断言

对于接口类型的表达式 `x`（但不是类型参数）和类型 `T`，表达式 `x.(T)` 断言 `x` 不是 `nil` 且存储在 `x` 中的值是类型 `T`。标记 `x.(T)` 称为类型断言。 

更准确地说，如果 `T` 不是接口类型，则 `x.(T)` 断言 `x` 的动态类型与类型 `T` 相同。在这种情况下，`T` 必须实现 `x` 的（接口）类型；否则类型断言无效，因为 `x` 不可能存储类型 `T` 的值。如果 `T` 是接口类型，则 `x.(T)` 断言 `x` 的动态类型实现了接口 `T`。

如果类型断言成立，则表达式的值是存储在 `x` 中的值，其类型为 `T`。如果类型断言为 `false`，则会发生运行时异常。换句话说，即使仅在运行时知道 `x` 的动态类型，在正确的程序中也知道 `x.(T)` 的类型是 `T`。

```go
var x interface{} = 7          // x has dynamic type int and value 7
i := x.(int)                   // i has type int and value 7

type I interface { m() }

func f(y I) {
	s := y.(string)        // illegal: string does not implement I (missing method m)
	r := y.(io.Reader)     // r has type io.Reader and the dynamic type of y must implement both I and io.Reader
	…
}
```

在赋值语句或特殊形式的初始化中使用的类型断言：

```go
v, ok = x.(T)
v, ok := x.(T)
var v, ok = x.(T)
var v, ok interface{} = x.(T) // dynamic types of v and ok are T and bool
```

类型断言会产生一个额外的无类型布尔值。如果断言成立，则 `ok` 的值为 `true`。否则，它是 `false`，而 `v` 的值是类型 `T` 的零值。在这种情况下不会发生运行时异常。

>---
#### 常量表达式

常量表达式可以只包含常量操作数，并在编译时计算。在合法使用布尔、数值和字符串类型的地方，可以分别使用非类型化的布尔、数值、字符串常量作为操作数。常量比较总是产生非类型化的布尔常量。如果常量移位表达式的左操作数是无类型常量，则结果是整数常量；否则它是与左操作数类型相同类型的常量，左操作数必须是整数类型。

对无类型常量的任何其他操作都将产生同一类型的无类型常量；即布尔常量、整数常量、浮点常量、复数常量或字符串常量。如果一个二元操作（除了移位）的无类型操作数是不同的类型，则结果是后面列表中出现的操作数的类型：整数、字符、浮点、复数。例如，一个无类型的整数常量除以一个无类型的复常量，得到一个无类型的复常量。

```go
const a = 2 + 3.0          // a == 5.0   (untyped floating-point constant)
const b = 15 / 4           // b == 3     (untyped integer constant)
const c = 15 / 4.0         // c == 3.75  (untyped floating-point constant)
const Θ float64 = 3/2      // Θ == 1.0   (type float64, 3/2 is integer division)
const Π float64 = 3/2.     // Π == 1.5   (type float64, 3/2. is float division)
const d = 1 << 3.0         // d == 8     (untyped integer constant)
const e = 1.0 << 3         // e == 8     (untyped integer constant)
const f = int32(1) << 33   // illegal    (constant 8589934592 overflows int32)
const g = float64(2) >> 1  // illegal    (float64(2) is a typed floating-point constant)
const h = "foo" > "bar"    // h == true  (untyped boolean constant)
const j = true             // j == true  (untyped boolean constant)
const k = 'w' + 1          // k == 'x'   (untyped rune constant)
const l = "hi"             // l == "hi"  (untyped string constant)
const m = string(k)        // m == "x"   (type string)
const Σ = 1 - 0.707i       //            (untyped complex constant)
const Δ = Σ + 2.0e-4       //            (untyped complex constant)
const Φ = iota*1i - 1/1i   //            (untyped complex constant)
```

将内置函数 `complex` 应用于无类型的整数、字符或浮点常量会生成无类型的复常量。

```go
const ic = complex(0, c)   // ic == 3.75i  (untyped complex constant)
const iΘ = complex(0, Θ)   // iΘ == 1i     (type complex128)
```

常量表达式总是精确计算；中间值和常量本身可能需要的精度远远大于语言中任何预先声明的类型所支持的精度。以下是合法的声明：

```go
const Huge = 1 << 100         // Huge == 1267650600228229401496703205376  (untyped integer constant)
const Four int8 = Huge >> 98  // Four == 4                                (type int8)
```

常量除法或余数运算的除数不能为零：

```go
3.14 / 0.0   // illegal: division by zero
```

类型化常量的值必须始终可以由常量类型的值准确表示。以下常量表达式是非法的：

```go
uint(-1)     // -1 cannot be represented as a uint
int(3.14)    // 3.14 cannot be represented as an int
int64(Huge)  // 1267650600228229401496703205376 cannot be represented as an int64
Four * 300   // operand 300 cannot be represented as an int8 (type of Four)
Four * 100   // product 400 cannot be represented as an int8 (type of Four)
```

一元按位求补运算符 `^` 使用的掩码与非常量规则匹配：对于无符号常量，掩码全为 1；对于有符号和无类型常量，掩码全为 -1。

```go
^1         // untyped integer constant, equal to -2
uint8(^1)  // illegal: same as uint8(-2), -2 cannot be represented as a uint8
^uint8(1)  // typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE)
int8(^1)   // same as int8(-2)
^int8(1)   // same as -1 ^ int8(1) = -2
```

实现限制：编译器可以在计算无类型浮点或复数常量表达式时使用舍入。这种舍入可能会导致浮点常量表达式在整数上下文中无效，即使它在使用无限精度计算时是整数，反之亦然。

>---
#### 类型转换

转换将表达式的类型更改为转换指定的类型。转换可能在源代码中按字面意思出现，也可能由出现表达式的上下文暗示。

显式转换是一个形式为 `T(x)` 的表达式，其中 `T` 是一个类型，`x` 是一个可以转换为类型 `T` 的表达式。

```ANTLR
Conversion = Type "(" Expression [ "," ] ")" 
```

如果类型以运算符 `*` 或 `<-` 开头，或者如果类型以关键字 `func` 开头并且没有结果列表，则必须在必要时将其括在括号中以避免歧义：

```go
*Point(p)        // same as *(Point(p))
(*Point)(p)      // p is converted to *Point
<-chan int(c)    // same as <-(chan int(c))
(<-chan int)(c)  // c is converted to <-chan int
func()(x)        // function signature func() x
(func())(x)      // x is converted to func()
(func() int)(x)  // x is converted to func() int
func() int(x)    // x is converted to func() int (unambiguous)
```

如果 `x` 可以用值 `T` 表示，则常量值 `x` 可以被转换为类型 `T`。作为特殊情况，整数常量 `x` 可以使用与非常量 `x` 相同的规则显式转换为字符串类型。

将常量转换为非类型参数的类型将产生类型化常量。

```go
uint(iota)               // iota value of type uint
float32(2.718281828)     // 2.718281828 of type float32
complex128(1)            // 1.0 + 0.0i of type complex128
float32(0.49999999)      // 0.5 of type float32
float64(-1e-1000)        // 0.0 of type float64
string('x')              // "x" of type string
string(0x266c)           // "♬" of type string
myString("foo" + "bar")  // "foobar" of type myString
string([]byte{'a'})      // not a constant: []byte{'a'} is not a constant
(*int)(nil)              // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type

int(1.2)                 // illegal: 1.2 cannot be represented as an int
string(65.0)             // illegal: 65.0 is not an integer constant
```

将常量转换为类型参数会产生该类型的非常量值，该值表示为实例化类型参数所用的类型参数的值。例如，给定函数：

```go
func f[P ~float32|~float64]() {
	… P(1.1) …
}
```

转换 `P(1.1)` 导致类型 `P` 的非常量值，并且值 `1.1` 根据 `f` 的类型参数被表示为 `float32` 或 `float64`。因此，如果 `f` 是用 `float32` 类型实例化的，则表达式 `P(1.1) + 1.2` 的数值将以与对应的非常量 `float32` 加法相同的精度来计算。

在以下任何情况下，非常量值 `x` 都可以转换为类型 `T`：
- `x` 可分配给 `T`。
- 忽略 `struct` 标记，`x` 的类型和 `T` 不是类型参数，但具有相同的底层类型。
- 忽略 `struct` 标记，`x` 的类型和 `T` 是指针类型，它们不是命名类型，它们的指针基类型不是类型参数，但具有相同的基础类型。
- `x` 的类型和 `T` 都是整数或浮点类型。
- `x` 的类型和 `T` 都是复数类型。
- `x` 是一个整数，或字节切片，或字符，`T` 是一个字符串类型。
- `x` 是一个字符串，`T` 是字节切片或字符。
- `x` 是一个切片，`T` 是一个数组或指向数组的指针，切片和数组类型具有相同的元素类型。

此外，如果 `T` 或 `x` 的类型 `V` 是类型参数，如果满足以下条件之一，`x` 可以转换为类型 `T`：
- `V` 和 `T` 都是类型参数，并且 `V` 的类型集中的每个类型的值可以被转换为 `T` 的类型集中的每个类型。
- 只有 `V` 是类型参数，并且 `V` 的类型集中的每个类型的值可以被转换为 `T`。
- 只有 `T` 是类型参数，而 `x` 可以转换为 `T` 的类型集中的每个类型。

当为了转换的目的而比较结构类型的标识时，忽略结构标记：

```go
type Person struct {
	Name    string
	Address *struct {
		Street string
		City   string
	}
}

var data *struct {
	Name    string `json:"name"`
	Address *struct {
		Street string `json:"street"`
		City   string `json:"city"`
	} `json:"address"`
}

var person = (*Person)(data)  // ignoring tags, the underlying types are identical
```

特定的规则适用于数值类型之间或与字符串类型之间的（非常量）转换。这些转换可能会改变 `x` 的表示，并产生运行时成本。所有其他转换只改变类型，而不是 `x` 的表示。

没有语言机制可以在指针和整数之间进行转换。软件包 *`unsafe`* 在受限环境下实现此功能。

<br>

##### 数值类型之间的转换

对于非常量数值的转换，以下规则适用：
- 在整数类型之间转换时，如果值是有符号整数，则将其符号扩展为隐式无限精度；否则将其零扩展。然后将其截断以适合结果类型的大小。例如，如果 `v := uint16(0x10F0)`，则 `uint32(int8(v)) == 0xFFFFFFF0`。转换总是产生一个有效的值；没有溢出的迹象。
- 当将浮点数转换为整数时，小数将被丢弃（向零截断）。
- 将整数或浮点数转换为浮点类型，或将复数转换为另一个复数类型时，结果值将舍入到目标类型指定的精度。例如，类型 `float32` 的变量 `x` 的值可以使用超过 IEEE-754 32 位数的精度的附加精度来存储，但是 `float 32(x)` 表示将 `x` 的值舍入到 32 位精度的结果。类似地，`x + 0.1` 可以使用超过 32 位的精度，但是 `float32(x + 0.1)` 不使用。

在所有涉及浮点或复数值的非常量转换中，如果结果类型不能表示值，则转换成功，但结果值依赖于实现。

<br>

##### 与字符串之间的转换

将字节切片转换为字符串类型会产生一个字符串，其连续字节是该切片的元素。

```go
string([]byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'})   // "hellø"
string([]byte{})                                     // ""
string([]byte(nil))                                  // ""

type bytes []byte
string(bytes{'h', 'e', 'l', 'l', '\xc3', '\xb8'})    // "hellø"

type myByte byte
string([]myByte{'w', 'o', 'r', 'l', 'd', '!'})       // "world!"
myString([]myByte{'\xf0', '\x9f', '\x8c', '\x8d'})   // "🌍"
```

将字符切片转换为字符串类型将生成一个字符串，该字符串是转换为字符串的各个字符值的拼接。

```go
string([]rune{0x767d, 0x9d6c, 0x7fd4})   // "\u767d\u9d6c\u7fd4" == "白鵬翔"
string([]rune{})                         // ""
string([]rune(nil))                      // ""

type runes []rune
string(runes{0x767d, 0x9d6c, 0x7fd4})    // "\u767d\u9d6c\u7fd4" == "白鵬翔"

type myRune rune
string([]myRune{0x266b, 0x266c})         // "\u266b\u266c" == "♫♬"
myString([]myRune{0x1f30e})              // "\U0001f30e" == "🌎"
```

将字符串类型的值转换为字节类型的切片会产生一个非空切片，其连续元素是字符串的字节。

```go
[]byte("hellø")             // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
[]byte("")                  // []byte{}

bytes("hellø")              // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}

[]myByte("world!")          // []myByte{'w', 'o', 'r', 'l', 'd', '!'}
[]myByte(myString("🌏"))    // []myByte{'\xf0', '\x9f', '\x8c', '\x8f'}
```

将字符串类型的值转换为字符类型的切片会生成包含字符串的各个 Unicode 码位的切片。

```go
[]rune(myString("白鵬翔"))   // []rune{0x767d, 0x9d6c, 0x7fd4}
[]rune("")                   // []rune{}

runes("白鵬翔")              // []rune{0x767d, 0x9d6c, 0x7fd4}

[]myRune("♫♬")              // []myRune{0x266b, 0x266c}
[]myRune(myString("🌐"))    // []myRune{0x1f310}
```

由于历史原因，整数值可能会转换为字符串类型。这种形式的转换生成一个字符串，其中包含 Unicode 码位的 UTF-8 表示（可能是多字节）和给定的整数值。有效 Unicode 码位范围之外的值将转换为 "`\uFFFD`"

```go
string('a')          // "a"
string(65)           // "A"
string('\xf8')       // "\u00f8" == "ø" == "\xc3\xb8"
string(-1)           // "\ufffd" == "\xef\xbf\xbd"

type myString string
myString('\u65e5')   // "\u65e5" == "日" == "\xe6\x97\xa5"
```

这种形式的转换最终可能会从语言中删除。go *vet* 工具将某些整数到字符串的转换标记为潜在错误。应该使用诸如 `utf8.AppendRune` 或 `utf8.EncodeRune` 之类的库函数。

<br>

##### 从切片到数组或数组指针的转换

将切片转换为数组会产生一个数组，其中包含切片的基础数组的元素。类似地，将切片转换为数组指针会产生指向切片的底层数组的指针。在这两种情况下，如果切片的长度小于数组的长度，则会发生运行异常。

```go
s := make([]byte, 2, 4)

a0 := [0]byte(s)
a1 := [1]byte(s[1:])     // a1[0] == s[1]
a2 := [2]byte(s)         // a2[0] == s[0]
a4 := [4]byte(s)         // panics: len([4]byte) > len(s)

s0 := (*[0]byte)(s)      // s0 != nil
s1 := (*[1]byte)(s[1:])  // &s1[0] == &s[1]
s2 := (*[2]byte)(s)      // &s2[0] == &s[0]
s4 := (*[4]byte)(s)      // panics: len([4]byte) > len(s)

var t []string
t0 := [0]string(t)       // ok for nil slice t
t1 := (*[0]string)(t)    // t1 == nil
t2 := (*[1]string)(t)    // panics: len([1]string) > len(t)

u := make([]byte, 0)
u0 := (*[0]byte)(u)      // u0 != nil
```

---
### 运算符

运算符将操作数组合成表达式：

```ANTLR
Expression = UnaryExpr | Expression binary_op Expression 
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr 

binary_op  = "||" | "&&" | rel_op | add_op | mul_op 
rel_op     = "==" | "!=" | "<" | "<=" | ">" | ">=" 
add_op     = "+" | "-" | "|" | "^" .
mul_op     = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" 

unary_op   = "+" | "-" | "!" | "^" | "*" | "&" | "<-" 
```

除了比较运算符，对于其他的二元运算符，操作数的类型必须相同，除非运算涉及移位或无类型常量。除移位运算外，如果一个操作数是无类型常量而另一个操作数不是，则该常量将隐式转换为另一个操作数的类型。

移位表达式中的右操作数必须是整数类型或可由类型 `uint` 的值表示的无类型常量。如果非常量移位表达式的左操作数是无类型常量，则首先将其隐式转换为移位表达式仅被其左操作数替换时所假定的类型。

```go
var a [1024]byte
var s uint = 33

// The results of the following examples are given for 64-bit ints.
var i = 1<<s                   // 1 has type int
var j int32 = 1<<s             // 1 has type int32; j == 0
var k = uint64(1<<s)           // 1 has type uint64; k == 1<<33
var m int = 1.0<<s             // 1.0 has type int; m == 1<<33
var n = 1.0<<s == j            // 1.0 has type int32; n == true
var o = 1<<s == 2<<s           // 1 and 2 have type int; o == false
var p = 1<<s == 1<<33          // 1 has type int; p == true
var u = 1.0<<s                 // illegal: 1.0 has type float64, cannot shift
var u1 = 1.0<<s != 0           // illegal: 1.0 has type float64, cannot shift
var u2 = 1<<s != 1.0           // illegal: 1 has type float64, cannot shift
var v1 float32 = 1<<s          // illegal: 1 has type float32, cannot shift
var v2 = string(1<<s)          // illegal: 1 is converted to a string, cannot shift
var w int64 = 1.0<<33          // 1.0<<33 is a constant shift expression; w == 1<<33
var x = a[1.0<<s]              // panics: 1.0 has type int, but 1<<33 overflows array bounds
var b = make([]byte, 1.0<<s)   // 1.0 has type int; len(b) == 1<<33

// The results of the following examples are given for 32-bit ints,
// which means the shifts will overflow.
var mm int = 1.0<<s            // 1.0 has type int; mm == 0
var oo = 1<<s == 2<<s          // 1 and 2 have type int; oo == true
var pp = 1<<s == 1<<33         // illegal: 1 has type int, but 1<<33 overflows int
var xx = a[1.0<<s]             // 1.0 has type int; xx == a[0]
var bb = make([]byte, 1.0<<s)  // 1.0 has type int; len(bb) == 0
```

>---
#### 运算符优先级

一元运算符具有最高的优先级。由于 `++` 和 `--` 运算符形成语句，而不是表达式，因此它们不属于运算符层次结构。因此，语句 `*p++` 与 `(*p)++` 相同。

二元运算符有五个优先级。依次是乘法运算符、加法运算符、比较运算符、 逻辑 AND、逻辑 OR：

```go
Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=  >  >=
    2             &&
    1             ||
```

具有相同优先级的二元运算符从左到右关联。例如， `x / y * z` 与 `(x / y) * z` 相同。

```go
+x                         // x
42 + a - b                 // (42 + a) - b
23 + 3*x[i]                // 23 + (3 * x[i])
x <= f()                   // x <= f()
^a >> b                    // (^a) >> b
f() || g()                 // f() || g()
x == y+1 && <-chanInt > 0  // (x == (y+1)) && ((<-chanInt) > 0)
```

>---
#### 算数运算符

算术运算符应用于数值并产生与第一个操作数相同类型的结果。四个标准算术运算符（`+`、`-`、`*`、`/`）适用于整数、浮点和复数类；`+` 也适用于字符串。按位逻辑运算符和移位运算符仅适用于整数。

```go
+    sum                    integers, floats, complex values, strings
-    difference             integers, floats, complex values
*    product                integers, floats, complex values
/    quotient               integers, floats, complex values
%    remainder              integers

&    bitwise AND            integers
|    bitwise OR             integers
^    bitwise XOR            integers
&^   bit clear (AND NOT)    integers

<<   left shift             integer << integer >= 0
>>   right shift            integer >> integer >= 0
```

如果操作数类型是类型参数，则运算符必须应用于该类型集中的每个类型。操作数表示为实例化类型参数所使用的类型参数的值，并且操作是使用该类型参数的精度计算的。例如，给定函数：

```go
func dotProduct[F ~float32|~float64](v1, v2 []F) F {
	var s F
	for i, x := range v1 {
		y := v2[i]
		s += x * y
	}
	return s
}
```

根据 `F` 的类型参数，分别以 `float32` 或 `float64` 精度计算乘积 `x * y` 和加法 `s += x * y`。

<br>

##### 整数运算符

对于两个整数值 `x` 和 `y`，整数商 `q = x / y` 和余数 `r = x % y` 满足关系 `x = q*y + r` 和 `|r| < |y|`。其中 `x / y` 向零截断（“截断除法”）：

```go
 x     y     x / y     x % y
 5     3       1         2
-5     3      -1        -2
 5    -3      -1         2
-5    -3       1        -2
```

此规则的一个例外是，如果被除数 `x` 是整数类型 `x` 的最大负值，则商 `q = x / -1` 等于 `x` （和 `r = 0` ），这是由于二进制补码整数溢出：

```go
                         x, q
int8                     -128
int16                  -32768
int32             -2147483648
int64    -9223372036854775808
```

如果除数是一个常量，它一定不能为零。如果除数在运行时为零，则会发生运行时异常。如果被除数是非负且是 2 的常量幂，则除法可以由右移代替，并且计算余数可以由按位 AND 操作代替：

```go
 x     x / 4     x % 4     x >> 2     x & 3
 11      2         3         2          3
-11     -2        -3        -3          1
```

移位运算符将左操作数移位右操作数指定的移位计数，该计数必须是非负的。如果在运行时移位计数为负，则会发生运行时异常。如果左操作数是有符号整数，则移位运算符实现算术移位；如果左操作数是无符号整数，则移位运算符实现逻辑移位。移位计数没有上限。`x << 1` 与 `x*2` 相同；`x >> 1` 与 `x/2` 相同，但向负无穷大截断。

对于整数操作数，一元运算符 `+`、`-` 和 `^` 定义如下：

```go
+x                          is 0 + x
-x    negation              is 0 - x
^x    bitwise complement    is m ^ x  with m = "all bits set to 1" for unsigned x
                                      and  m = -1 for signed x
```

<br>

##### 整数溢出

对于无符号整数值，运算 `+`、`-`、`*` 和 `<<` 是以模 $2^n$ 计算的，其中 $n$ 是无符号整数类型的位宽。不严格地说，这些无符号整数操作在溢出时丢弃高位，程序可能依赖于 “回绕”。

对于有符号整数，操作 `+`、`-`、`*`、`/` 和 `<<` 可以合法地溢出，并且结果值存在并且由有符号整数表示、操作及其操作数确定性地定义。溢出不会导致运行时异常。编译器可能不会在不发生溢出的假设下优化代码。例如，它可以不假设 `x < x + 1` 总是为真。

<br>

##### 浮点运算符

对于浮点数和复数，`+x` 与 `x` 相同，而 `-x` 是 `x` 的负数。除了 IEEE-754 标准之外，没有指定浮点数或复数除以零的结果；是否发生运行时异常是特定于实现的。

实现可以将多个浮点操作合并成单个融合操作（可能跨语句），并且产生与通过单独执行并舍入指令所获得的值不同的结果。显式浮点类型转换将舍入到目标类型的精度，从而防止丢弃该舍入的融合。

例如，一些架构提供 “融合乘加”（FMA）指令，其计算 `x*y + z` 而不舍入中间结果 `x*y`。这些例子展示了 Go 语言实现何时可以使用该指令：

```go
// FMA allowed for computing r, because x*y is not explicitly rounded:
r  = x*y + z
r  = z;   r += x*y
t  = x*y; r = t + z
*p = x*y; r = *p + z
r  = x*y + float64(z)

// FMA disallowed for computing r, because it would omit rounding of x*y:
r  = float64(x*y) + z
r  = z; r += float64(x*y)
t  = float64(x*y); r = t + z
```

<br>

##### 字符串连接

字符串可以使用 `+` 操作符或 `+=` 赋值操作符连接：

```go
s := "hi" + string(c)
s += " and good bye"
```

字符串加法通过连接操作数创建一个新字符串。

>---
#### 比较运算符

比较运算符比较两个操作数并产生一个无类型的布尔值。

```go
==    equal
!=    not equal
<     less
<=    less or equal
>     greater
>=    greater or equal
```

在任何比较中，第一个操作数必须可分配给第二个操作数的类型，反之亦然。

相等运算符 `==` 和 `!=` 适用于可比类型的操作数。排序运算符 `<`、`<=`、`>` 和 `>=` 适用于有序类型的操作数。这些项和比较结果定义如下：
- 布尔类型是可比较的。如果两个布尔值都是 `true` 或都是 `false`，则它们相等。
- 整数类型是可比较和有序的。以通常的方式进行比较。
- 浮点类型是可比较和有序的。按照 IEEE-754 标准的定义比较两个浮点值。
- 复数类型是可比较的。如果 `real(u) == real(v)` 和 `imag(u) == imag(v)`，则两个复数值 `u` 和 `v` 相等。
- 字符串类型是可比较和有序的。两个字符串值按字节进行词法比较。
- 指针类型具有可比性。如果两个指针指向同一个变量，或者两个指针都有值 `nil`，则它们相等。指向不同的零大小变量的指针可能相等，也可能不相等。
- 通道类型具有可比性。如果两个通道值是由同一个 `make` 的调用创建的，或者两个通道值都具有值 `nil`，则它们相等。
- 不是类型参数的接口类型是可比较的。如果两个接口值具有相同的动态类型和相同的动态值，或者两者都具有值 `nil`，则它们相等。
- 如果类型 `X` 是可比较的并且 `X` 实现 `T`，则可以比较非接口类型 `X` 的值 `x` 和接口类型 `T` 的值 `t`。如果 `t` 的动态类型与 `X` 相同，并且 `t` 的动态值等于 `x`，则它们相等。
- 如果结构类型的所有字段类型都是可比较的，则结构类型是可比较的。如果两个结构值对应的非空字段值相等，则它们相等。字段按源顺序进行比较，一旦两个字段值不同（或所有字段都已比较），比较就会停止。
- 如果数组元素类型是可比较的，则数组类型是可比较的。如果它们对应的元素值相等，两个数组值相等。元素按索引升序进行比较，一旦两个元素值不同（或所有元素都已比较），比较就会停止。
- 如果类型参数是 *strictly comparable* 的，则它们是可比较的。

比较具有相同动态类型的两个接口值时，如果该类型不可比较，则会导致运行时异常。此行为不仅适用于直接接口值比较，而且适用于比较带有接口值字段的接口值数组或结构体。

切片、映射和函数类型是不可比较的。然而，作为特殊情况，可以将切片、映射或函数值与预先声明的标识符 `nil` 进行比较。也允许将指针、通道和接口值与 `nil` 进行比较，并遵循上述一般规则。

```go
const c = 3 < 4            // c is the untyped boolean constant true

type MyBool bool
var x, y int
var (
	// The result of a comparison is an untyped boolean.
	// The usual assignment rules apply.
	b3        = x == y // b3 has type bool
	b4 bool   = x == y // b4 has type bool
	b5 MyBool = x == y // b5 has type MyBool
)
```

一个类型如果它是可比较的，并且不是接口类型，也不是由接口类型组成的，则它是严格可比较（*strictly comparable*）的。具体而言：
- 布尔、数值、字符串、指针和通道等类型是严格可比的。
- 如果结构类型的所有字段类型都是严格可比的，则结构类型是严格可比的。
- 如果数组元素类型是严格可比较的，则数组类型是严格可比较的。
- 如果类型参数的类型集中的所有类型都是严格可比较的，则类型参数是严格可比较的。

>---
#### 逻辑运算符

逻辑运算符应用于布尔值，并产生与操作数相同类型的结果。遵从短路原则：

```go
&&    conditional AND    p && q  is  "if p then q else false"
||    conditional OR     p || q  is  "if p then true else q"
!     NOT                !p      is  "not p"
```

>---
#### 地址运算符

对于类型 `T` 的操作数 `x`，地址操作 `&x` 生成指向 `x` 的 `*T` 类型指针。操作数必须是可寻址的，也就是说，要么是变量、指针间接或切片索引操作；要么是可寻址结构操作数的字段选择器；要么是可寻址数组的数组索引操作。作为可寻址性要求的一个例外，`x` 也可以是一个（可能带括号的）复合文本。如果对 `x` 的求值会导致运行时异常，那么对 `&x` 的求值也会。

对于指针类型 `*T` 的操作数 `x`，指针间接寻址 `*x` 表示由 `x` 指向的类型 `T` 的变量。如果 `x` 是 `nil`，则尝试计算 `*x` 将导致运行时异常。

```go
&x
&a[f(2)]
&Point{2, 3}
*p
*pf(x)

var x *int = nil
*x   // causes a run-time panic
&*x  // causes a run-time panic
```

>---
#### 接收运算符

对于核心类型是通道的操作数 `ch`，接收操作 `<-ch` 的值是从通道 `ch` 接收的值。通道方向必须允许接收操作，并且接收操作的类型是通道的元素类型。表达式将一直阻塞，直到有可用的值。从 `nil` 通道接收永远阻塞。封闭通道上的接收操作总是可以立即进行，在接收到任何先前发送的值之后，生成元素类型的零值。

```go
v1 := <-ch
v2 = <-ch
f(<-ch)
<-strobe  // wait until clock pulse and discard received value
```

在赋值语句或特殊形式的初始化中使用的接收表达式：

```go
x, ok = <-ch
x, ok := <-ch
var x, ok = <-ch
var x, ok T = <-ch
```

接收表达式产生一个额外的无类型的布尔结果，报告通信是否成功。如果接收到的值是通过成功的发送操作传递到通道的，则 `ok` 的值为 `true`；如果它是由于通道关闭且为空而生成的零值，则为 `false`。

>---
#### 求值顺序

在包级别，初始化依赖项确定变量声明中各个初始化表达式的计算顺序。否则，在计算表达式、赋值或返回语句的操作数时，所有函数调用、方法调用、接收操作和二元逻辑操作都将按词法从左到右的顺序进行计算。

例如，在（function-local）赋值中

```go
y[f()], ok = g(z || h(), i()+x[j()], <-c), k()
```

函数调用和通信按顺序 `f()`、`h()`（如果 `z` 计算为 `false`）、`i()`、`j()`、`<-c`、`g()` 和 `k()` 发生。然而，与 `x` 的求值和索引以及 `y` 和 `z` 的求值相比，这些事件的顺序没有被指定，除非在词汇上需要。例如，在计算其参数之前，不能调用 `g`。

```go
a := 1
f := func() int { a++; return a }
x := []int{a, f()}            // x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specified
m := map[int]int{a: 1, a: 2}  // m may be {2: 1} or {2: 2}: evaluation order between the two map assignments is not specified
n := map[int]int{a: f()}      // n may be {2: 3} or {3: 3}: evaluation order between the key and the value is not specified
```

在包级别，初始化依赖项会覆盖各个初始化表达式的从左到右规则，但不会覆盖每个表达式中的操作数：

```go
var a, b, c = f() + v(), g(), sqr(u()) + v()

func f() int        { return c }
func g() int        { return a }
func sqr(x int) int { return x*x }

// functions u and v are independent of all other variables and functions
```

函数调用的顺序是 `u()`、`sqr()`、`v()`、`f()`、`v()` 和 `g()`。

单个表达式中的浮点运算根据运算符的结合性进行计算。显式括号通过覆盖默认关联性来影响计算。在表达式 `x + (y + z)` 中，在添加 `x` 之前执行添加 `y + z`。

---
### 语句

语句控制执行。

```ANTLR
Statement =
	Declaration | LabeledStmt | SimpleStmt |
	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
	DeferStmt 

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl 
```

>---
#### 空语句

空语句什么也不做。

```ANTLR
EmptyStmt =  
```
```go
for{
}
```

>---
#### 终止语句

终止语句中断块中的常规控制流。以下语句将终止：
- `return` 或 `goto` 语句。
- 调用内置函数 `panic`。
- 语句列表以终止语句结束的块。
- 一个 `if` 语句，其中：
  - 存在 `else` 分支，且；
  - 两个分支都是终止语句。
- 一个 `for` 语句，其中：
  - 没有 `break` 语句引用 `for` 语句，并且；
  - 循环条件不存在，并且；
  - `for` 语句不使用范围子句。
- 一个 `switch` 语句，其中：
  - 没有 `break` 语句引用 `switch` 语句
  - 存在 `default` 分支，并且；
  - 该语句列出来每种分支下的语句，包括 `default`、终止语句或可能标记为 `fallthrough` 的语句。
- 一个 `select` 语句，其中：
  - 没有 `break` 语句引用 `select` 语句，并且；
  - 语句列表在每种分支下，包括 `default`（如果存在），都以终止语句结束。
- 标签语句，它标记一个终止语句。

其他语句不会终止。如果语句列表不为空，并且其最后一个非空语句是终止语句，则语句列表以终止语句结束。

>---
#### 标签语句

带标签语句可以是 `goto`、`break` 或 `continue` 语句的目标。

```ANTLR
LabeledStmt = Label ":" Statement 
Label       = identifier 
```
```go
func foo(){
    // ...
Error: 
    log.Panic("error encountered")
    // ...
}
```

>--- 
#### 表达式语句

除了特定的内置函数外，函数和方法调用以及接收操作都可以出现在语句上下文中。这些表述可以加括号。

```ANTLR
ExpressionStmt = Expression 
```

语句上下文中不允许使用以下内置函数：

```go
append
cap
complex
imag
len
make
new
real
unsafe.Add
unsafe.Alignof
unsafe.Offsetof
unsafe.Sizeof
unsafe.Slice
unsafe.SliceData
unsafe.String
unsafe.StringData
```
```go
h(x+y)
f.Close()
<-ch
(<-ch)
len("foo")  // illegal if len is the built-in function
```

>---
#### 发送语句

*send* 语句在通道上发送一个值。通道表达式的核心类型必须是通道，通道方向必须允许发送操作，并且要发送的值的类型必须可分配给通道的元素类型。

```ANTLR
SendStmt = Channel "<-" Expression 
Channel  = Expression 
```

在通信开始之前，通道和值表达式都被求值。通信阻塞，直到发送可以继续。如果接收方准备就绪，则可以在无缓冲通道上进行发送。如果缓冲区中有空间，则缓冲通道上的发送可以继续。在关闭的通道上发送会导致运行时异常。在 `nil` 通道上发送将永远阻塞。

```go
ch <- 3  // send value 3 to channel ch
```

>---
#### IncDec 语句

“`++`” 和 “`--`” 语句通过无类型常量 1 增加或减少其操作数。与赋值一样，操作数必须是可寻址的或映射索引表达式。

```ANTLR
IncDecStmt = Expression ( "++" | "--" ) 
```

以下赋值语句在语义上是等效的：

```go
IncDec statement    Assignment
x++                 x += 1
x--                 x -= 1
```

>--- 
#### 赋值语句

赋值将变量中存储的当前值替换为表达式指定的新值。赋值语句可以将单个值赋给单个变量，或者将多个值赋给匹配数量的变量。

```ANTLR
Assignment = ExpressionList assign_op ExpressionList 
assign_op = [ add_op | mul_op ] "=" 

add_op     = "+" | "-" | "|" | "^" .
mul_op     = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" 
```

每个左侧操作数必须是可寻址的，映射索引表达式，或（仅适用于 `=` 赋值）空白标识符。操作数可以加括号。

```go
x = 1
*p = f()
a[i] = 23
(k) = <-ch  // same as: k = <-ch
_ = g()
```

一个赋值操作 `x op = y`，其中 `op` 是一个二元算术运算符，它等价于 `x = x op (y)`，但只计算 `x` 一次。`op=` 构造是单个令牌。在赋值操作中，左边和右边的表达式列表必须只包含一个单值表达式，并且左边的表达式不能是空标识符。

```go
a[i] <<= 2
i &^= 1<<n
```

元组赋值将多值运算的各个元素赋值给变量列表。有两种形式。在第一种情况下，右操作数是单个多值表达式，例如函数调用、通道或映射操作或类型断言。左操作数必须与值的数量相匹配。例如，如果 `f` 是一个返回两个值的函数：

```go
x, y = f()
```

将第一个值分配给 `x`，将第二个值分配给 `y`。在第二种形式中，左边的操作数必须等于右边的表达式的数量，每个表达式都必须是单值的，右边的第 n 个表达式被分配给左边的第 n 个操作数：

```go
one, two, three = '一', '二', '三'
```

空白标识符提供了一种在赋值中忽略右侧值的方法：

```go
_ = x       // evaluate x but ignore it
x, _ = f()  // evaluate f() but ignore second result value
```

分配分两个阶段进行。首先，左边的索引表达式和指针间接（包括选择器中的隐式指针间接）的操作数和右边的表达式都按通常的顺序计算。其次，分配是按从左到右的顺序进行的。

```go
a, b = b, a  // exchange a and b

x := []int{1, 2, 3}
i := 0
i, x[i] = 1, 2  // set i = 1, x[0] = 2

i = 0
x[i], i = 2, 1  // set x[0] = 2, i = 1

x[0], x[0] = 1, 2  // set x[0] = 1, then x[0] = 2 (so x[0] == 2 at end)

x[1], x[3] = 4, 5  // set x[1] = 4, then panic setting x[3] = 5.

type Point struct { x, y int }
var p *Point
x[2], p.x = 6, 7  // set x[2] = 6, then panic setting p.x = 7

i = 2
x = []int{3, 5, 7}
for i, x[i] = range x {  // set i, x[2] = 0, x[0]
	break
}
// after this loop, i == 0 and x is []int{3, 5, 3}
```

在赋值运算中，每个值都必须可以赋值给它所赋给的操作数的类型，但有以下特殊情况：
- 任何类型的值都可以分配给空白标识符。
- 如果将非类型化常量赋给接口类型的变量或空标识符，则首先将该常量隐式转换为其默认类型。
- 如果一个非类型化的布尔值被赋给一个接口类型的变量或空标识符，它首先被隐式转换为类型 `bool`。

>---
#### if 语句

```go
IfStmt = "if" [ SimpleStmt ";" ] Expression Block [ "else" ( IfStmt | Block ) ] 
```
```go
if x > max {
	x = max
}
```

表达式前面可以有一个简单语句，该语句在表达式求值之前执行。

```go
if x := f(); x < y {
	return x
} else if x > z {
	return z
} else {
	return y
}
```

>---
#### Switch 语句
 
`Switch` 语句提供多路执行。将表达式或类型与 “`switch`” 内的 “`case`” 进行比较，以确定执行哪个分支。

```ANTLR
SwitchStmt = ExprSwitchStmt | TypeSwitchStmt 
```

有两种形式：*ExprSwitch* 和 *TypeSwitch*。在 *ExprSwitch* 中，`case` 包含与 `switch` 表达式的值进行比较的表达式。在 *TypeSwitch* 中，`case` 包含的类型与特殊注释的开关表达式的类型进行比较。`switch` 表达式只计算一次。

<br>

##### Expression switch

在 *ExprSwitch* 中，求值 `switch` 表达式，`case` 表达式（不需要是常量）被从左到右和从上到下求值；首个等于 `switch` 表达式的表达式触发相关 `case` 的语句的执行；其他 `case` 被跳过。如果没有匹配的 `case`，并且存在 `default`，则执行其语句。最多只能有一个 `default`，它可以出现在 `switch` 语句中的任何地方。缺少的 `switch` 表达式等效于布尔值 `true`。

```ANTLR
ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" 
ExprCaseClause = ExprSwitchCase ":" StatementList 
ExprSwitchCase = "case" ExpressionList | "default" 
```

如果 `switch` 表达式计算为无类型常量，则首先将其隐式转换为默认类型。预先声明的非类型化值 `nil` 不能用作 `switch` 表达式。`switch` 表达式类型必须是可比较的。

如果 `case` 表达式是无类型的，则首先将其隐式转换为 `switch` 表达式的类型。对于每个（可能已转换的）`case` 表达式 `x` 和 `switch` 表达式的值 `t`，`x == t` 必须是有效的比较。

`switch` 表达式被视为用于声明和初始化没有显式类型的临时变量 `t`；它是每个 `case` 表达式 `x` 测试相等性的 `t` 的值。

在 `case` 或 `default` 子句中，最后一个非空语句可以是（可能标记为）“`fallthrough`” 语句，以指示控制应该从该子句的末尾流向下一个子句的第一个语句。否则，控制流到 “`switch`” 语句的末尾。“`fallthrough`” 语句可能作为 *ExprSwitch* 的最后一个子句以外的所有语句的最后一个语句出现。

`switch` 表达式前面可以有一个简单语句，该语句在表达式求值之前执行。

```go
switch tag {
default: s3()
case 0, 1, 2, 3: s1()
case 4, 5, 6, 7: s2()
}

switch x := f(); {  // missing switch expression means "true"
case x < 0: return -x
default: return x
}

switch {
case x < y: f1()
case x < z: f2()
case x == 4: f3()
}
```

实现限制：编译器可能不允许多个 `case` 表达式计算同一个常量。例如，当前的编译器不允许在 `case` 表达式中使用重复的整数、浮点数或字符串常量。

<br>

##### Type switch

*TypeSwitch* 比较类型而不是值。它在其他方面类似于 *ExprSwitch*。它由一个特殊的 `switch` 表达式标记，该表达式具有使用关键字 `type` 而不是实际类型的类型断言的形式：

```go
switch x.(type) {
// cases
}
```

然后，用例将实际类型 `T` 与表达式 `x` 的动态类型进行匹配。与类型断言一样，`x` 必须是接口类型，但不是类型参数，并且 `case` 中列出的每个非接口类型 `T` 必须实现 `x` 的类型。`case` 列出的类型必须全部不同。

```ANTLR
TypeSwitchStmt  = "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}" 
TypeSwitchGuard = [ identifier ":=" ] PrimaryExpr "." "(" "type" ")" 
TypeCaseClause  = TypeSwitchCase ":" StatementList 
TypeSwitchCase  = "case" TypeList | "default" 
```

*TypeSwitchGuard* 可以包括短变量声明。当使用这种形式时，变量在每个子句的隐式块中的 *TypeSwitchCase* 的末尾声明。在 *case* 只列出一种类型的子句中，变量具有该类型；否则，变量具有 *TypeSwitchGuard* 中表达式的类型。

`case` 可以使用预先声明的标识符 `nil`；当 *TypeSwitchGuard* 中的表达式是 `nil` 接口值时，选择该 `case`。最多可能有一个 `case nil`。
 
给定类型为 `interface{}` 的表达式 `x`，以下 *TypeSwitch*：

```go
switch i := x.(type) {
case nil:
	printString("x is nil")                // type of i is type of x (interface{})
case int:
	printInt(i)                            // type of i is int
case float64:
	printFloat64(i)                        // type of i is float64
case func(int) float64:
	printFunction(i)                       // type of i is func(int) float64
case bool, string:
	printString("type is bool or string")  // type of i is type of x (interface{})
default:
	printString("don't know the type")     // type of i is type of x (interface{})
}
```

可以重写为：

```go
v := x  // x is evaluated exactly once
if v == nil {
	i := v                                 // type of i is type of x (interface{})
	printString("x is nil")
} else if i, isInt := v.(int); isInt {
	printInt(i)                            // type of i is int
} else if i, isFloat64 := v.(float64); isFloat64 {
	printFloat64(i)                        // type of i is float64
} else if i, isFunc := v.(func(int) float64); isFunc {
	printFunction(i)                       // type of i is func(int) float64
} else {
	_, isBool := v.(bool)
	_, isString := v.(string)
	if isBool || isString {
		i := v                         // type of i is type of x (interface{})
		printString("type is bool or string")
	} else {
		i := v                         // type of i is type of x (interface{})
		printString("don't know the type")
	}
}
```

类型参数或泛型类型可以用作 `case` 中的类型。如果在实例化时，该类型与 `switch` 中的另一个项重复，则选择第一个匹配的 `case`。

```go
func f[P any](x any) int {
	switch x.(type) {
	case P:
		return 0
	case string:
		return 1
	case []P:
		return 2
	case []byte:
		return 3
	default:
		return 4
	}
}

var v1 = f[string]("foo")   // v1 == 0
var v2 = f[byte]([]byte{})  // v2 == 2
```

*TypeSwitchGuard* 之前可以有一个简单语句，该语句在该 `type case` 分支求值之前执行。*TypeSwitch* 中不允许使用 “`fallthrough`” 语句。

<br>

##### fallthrough

“`fallthrough`” 语句将控制转移到表达式 “`switch`” 语句中下一个 `case` 子句的第一个语句。它只能用作此类子句中的最后一个非空语句。

```ANTLR
FallthroughStmt = "fallthrough" 
```
```go
func Fun(v int) int {
	switch v {
	case 1:
		v++
		fallthrough
	case 2:
		print("fallthrough")
	default:
	}
	return v
}
```

>---
#### For 语句

“`for`” 语句指定重复执行一个块。有三种形式：迭代可以由单条件、“`for`” 子句或 “`range`” 子句控制。

```ANTLR
ForStmt = "for" [ Condition | ForClause | RangeClause ] Block 
Condition = Expression 
```

<br>

##### 单条件控制

在其最简单的形式中，“`for`” 语句在布尔条件的计算结果为 `true` 时，就重复执行一次循环体块。在每次迭代之前计算条件。如果条件不存在，则等效于布尔值 `true`。

```go
for a < b {
	a *= 2
}
```

<br>

##### For 子句控制

带有 *ForClause* 的 “`for`” 语句也受其条件控制；除条件表达式外，它还可以指定一个 *init* 子句和一个 *post* 子句语句，如赋值、递增或递减语句。*init* 子句可以是一个简短的变量声明，但 *post* 语句不能。

```ANTLR
ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] 
InitStmt = SimpleStmt 
PostStmt = SimpleStmt 
```
```go
for i := 0; i < 10; i++ {
	f(i)
}
```

如果非空，则 *init* 语句在第一次迭代计算条件之前执行一次；*post* 语句在每次执行块之后执行（并且仅在块被执行时执行）。*ForClause* 的任何元素都可以为空，但除非只有一个条件，否则必须使用括号。如果条件不存在，则等效于布尔值 `true`。

```go
for cond { S() }    is the same as    for ; cond ; { S() }
for      { S() }    is the same as    for true     { S() }
```

每次迭代都有自己独立的声明变量（或变量）。第一次迭代使用的变量由 *init* 语句声明。每次后续迭代使用的变量在执行 *post* 语句之前隐式声明，并初始化为上一次迭代的变量的值。

```go
var prints []func()
for i := 0; i < 5; i++ {
	prints = append(prints, func() { println(i) })
	i++
}
for _, p := range prints {
	p()   // 1,3,5
}
```

在 Go 1.22 之前，迭代共享一组变量，而不是拥有自己独立的变量。在这种情况下，上面的示例将打印 `6,6,6`。

<br>

##### Range 子句控制

带有 “`range`” 子句的 “`for`” 语句迭代数组、切片、字符串或映射的所有项、通道上接收的值或从零到上限的整数值。对于每个项，它将迭代值分配给相应的迭代变量（如果存在），然后执行该块。

```ANTLR
RangeClause = [ ExpressionList "=" | IdentifierList ":=" ] "range" Expression 
```

“`range`” 子句中右边的表达式称为范围表达式，其核心类型必须是数组、指向数组的指针、切片、字符串、映射、允许接收操作的通道或整数。与赋值一样，如果存在的话，左边的操作数必须是可寻址的或映射索引表达式；它们表示迭代变量。如果范围表达式是通道或整数，则最多允许一个迭代变量，否则最多可以有两个。如果最后一个迭代变量是空标识符，则 `range` 子句等效于没有该标识符的同一子句。

范围表达式 `x` 在开始循环之前被求值一次，但有一个例外：如果最多存在一个迭代变量并且 `len(x)` 是常量，则范围表达式不被求值。

左边的函数调用在每次迭代中计算一次。对于每次迭代，如果存在相应的迭代变量，则如下产生迭代值：

```go
Range expression                          1st value          2nd value

array or slice  a  [n]E, *[n]E, or []E    index    i  int    a[i]       E
string          s  string type            index    i  int    see below  rune
map             m  map[K]V                key      k  K      m[k]       V
channel         c  chan E, <-chan E       element  e  E
integer         n  integer type           value    i  see below
```

- 对于数组、指向数组的指针或切片值 `a`，索引迭代值从元素索引 `0` 开始按递增顺序生成。如果最多存在一个迭代变量，则范围循环产生从 `0` 到 `len(a)-1` 的迭代值，并且不索引到数组或切片本身。对于 `nil` 切片，迭代次数为 0。

+ 对于字符串值 `s`，“`range`” 子句从字节索引 `0` 开始迭代字符串中的 Unicode 码点。在连续迭代中，索引值将是字符串中连续 UTF-8 编码的代码点的第一个字节的索引，第二个值（类型为 `rune`）将是相应代码点的值。如果迭代遇到无效的 UTF-8 序列，第二个值将是 0xFFFD（Unicode 替换字符，替换无法识别的字符），下一次迭代将在字符串中前进一个字节。

- 映射上的迭代顺序没有指定，也不能保证从一次迭代到下一次迭代都是相同的。如果在迭代过程中删除了尚未到达的映射项，则不会产生相应的迭代值。如果映射项是在迭代期间创建的，则该项可以在迭代期间产生或者可以被跳过。对于创建的每个项，以及从一个迭代到下一个迭代，选择可能会有所不同。如果映射为 `nil`，则迭代次数为 0。

+ 对于通道，产生的迭代值是在通道上发送的连续值，直到通道关闭。如果通道为 `nil`，则范围表达式将永远阻塞。
  
- 对于整数值 n ，迭代值 `0` 到 `n-1` 按递增顺序产生。如果 `n <= 0`，则循环不运行任何迭代。

迭代变量可以由 “`range`” 子句使用短变量声明（`:=`）的形式来声明。在这种情况下，它们的作用域是 “`for`” 语句的块，并且每次迭代都有自己的新变量（参见带有 *ForClause* 的 “`for`” 语句）。如果范围表达式是一个（可能是无类型的）整数表达式 `n`，则变量的类型与初始化表达式 `n` 声明的类型相同。否则，变量具有其各自迭代值的类型。

如果迭代变量没有被 “`range`” 子句显式声明，它们必须是预先存在的。在这种情况下，迭代值被分配给各个变量，就像在赋值语句中一样。如果范围表达式是一个（可能是无类型的）整数表达式 `n`，则 `n` 也必须可分配给迭代变量；如果没有迭代变量，则 `n` 必须可分配给 `int`。

```go
var testdata *struct {
	a *[7]int
}
for i, _ := range testdata.a {
	// testdata.a is never evaluated; len(testdata.a) is constant
	// i ranges from 0 to 6
	f(i)
}

var a [10]string
for i, s := range a {
	// type of i is int
	// type of s is string
	// s == a[i]
	g(i, s)
}

var key string
var val interface{}  // element type of m is assignable to val
m := map[string]int{"mon":0, "tue":1, "wed":2, "thu":3, "fri":4, "sat":5, "sun":6}
for key, val = range m {
	h(key, val)
}
// key == last map key encountered in iteration
// val == map[key]

var ch chan Work = producer()
for w := range ch {
	doWork(w)
}

// empty a channel
for range ch {}

// call f(0), f(1), ... f(9)
for i := range 10 {
	// type of i is int (default type for untyped constant 10)
	f(i)
}

// invalid: 256 cannot be assigned to uint8
var u uint8
for u = range 256 {
}
```

>---
#### Go 语句

“`go`” 语句在同一地址空间内作为一个独立的并发控制线程或 *goroutine* 开始执行函数调用。

```ANTLR
GoStmt = "go" Expression 
```

表达式必须是函数或方法调用；不能用括号括起来。内置函数的调用与表达式语句一样受到限制。

函数值和参数在调用 *goroutine* 中照常进行计算，但与常规调用不同的是，程序执行不会等待被调用函数完成。相反，函数在一个新的 *goroutine* 中独立执行。当函数终止时，它的 *goroutine* 也终止。如果函数有任何返回值，则它们在函数完成时被丢弃。

```go
go Server()
go func(ch chan<- bool) { for { sleep(10); ch <- true }} (c)
```

>--- 
#### Select 语句

“`select`” 语句选择一组可能的发送或接收操作中的哪一个将继续。它看起来类似于 “`switch`” 语句，但所有的 `case` 都涉及通信操作。

```ANTLR
SelectStmt = "select" "{" { CommClause } "}" 
CommClause = CommCase ":" StatementList 
CommCase   = "case" ( SendStmt | RecvStmt ) | "default" 
RecvStmt   = [ ExpressionList "=" | IdentifierList ":=" ] RecvExpr 
RecvExpr   = Expression 
```

带有 *RecvStmt* 的情况可以将 *RecvExpr* 的结果分配给一个或两个变量，可以使用短变量声明。*RecvExpr* 必须是接收操作（可能带括号）。最多只能有一个 `default` 分支，它可能出现在 `case` 列表中的任何位置。

“`select`” 语句的执行分为几个步骤：
  1. 对于语句中的所有 `case`，接收操作的通道操作数和发送语句的通道和右侧表达式在进入 “`select`” 语句时按源顺序只计算一次。结果是一组要接收或发送的通道，以及要发送的相应值。该求值中的任何副作用都将发生，而不管选择进行哪个（如果有的话）通信操作。*RecvStmt* 左侧带有短变量声明或赋值的表达式尚未计算。
  2. 如果一个或多个通信可以进行，则经由统一的伪随机选择来选择可以进行的单个通信。否则，如果存在 `default`，则选择该分支。如果没有 `default`，则 “`select`” 语句阻塞，直到至少有一个通信可以继续。
  3. 除非所选择的分支是 `default`，否则执行相应的通信操作。
  4. 如果所选的 `case` 是带有短变量声明或赋值的 *RecvStmt*，则计算左侧表达式并赋值接收到的值。
  5. 执行所选 `case` 的语句列表。

由于 `nil` 通道上的通信永远无法继续，因此只有 `nil` 通道且没有 `default` 的选择将永远阻塞。

```go
var a []int
var c, c1, c2, c3, c4 chan int
var i1, i2 int
select {
case i1 = <-c1:
	print("received ", i1, " from c1\n")
case c2 <- i2:
	print("sent ", i2, " to c2\n")
case i3, ok := (<-c3):  // same as: i3, ok := <-c3
	if ok {
		print("received ", i3, " from c3\n")
	} else {
		print("c3 is closed\n")
	}
case a[f()] = <-c4:
	// same as:
	// case t := <-c4
	//	a[f()] = t
default:
	print("no communication\n")
}

for {  // send random sequence of bits to c
	select {
	case c <- 0:  // note: no statement, no fallthrough, no folding of cases
	case c <- 1:
	}
}

select {}  // block forever
```

>--- 
#### Return 语句

函数 `F` 中的 “`return`” 语句终止 `F` 的执行，并可选地提供一个或多个结果值。任何被 `F` 延迟的函数都会在 `F` 返回给它的调用方之前执行。

```ANTLR
ReturnStmt = "return" [ ExpressionList ] 
```

在没有结果类型的函数中，“`return`” 语句不能指定任何结果值。

```go
func noResult() {
	return
}
```

有三种方法可以从具有结果类型的函数返回值：
1. 返回值可以在 “`return`” 语句中显式列出。每个表达式都必须是单值的，并且可分配给函数结果类型的相应元素。

	```go
	func simpleF() int {
		return 2
	}

	func complexF1() (re float64, im float64) {
		return -7.0, -4.0
	}
	```

2. “`return`” 语句中的表达式列表可以是对多值函数的单个调用。其效果就好像从该函数返回的每个值都被分配给一个具有相应值类型的临时变量，后跟一个列出这些变量的 “`return`” 语句，此时适用前一种情况的规则。

	```go
	func complexF2() (re float64, im float64) {
		return complexF1()
	}
	```

3. 如果函数的结果类型指定了其结果参数的名称，则表达式列表可能为空。结果参数作为普通的局部变量，函数可以根据需要为它们赋值。“`return`” 语句返回这些变量的值。

	```go
	func complexF3() (re float64, im float64) {
		re = 7.0
		im = 4.0
		return
	}

	func (devnull) Write(p []byte) (n int, _ error) {
		n = len(p)
		return
	}
	```

不管它们是如何声明的，所有的结果值在进入函数时都被初始化为它们的类型的零值。指定结果的 “`return`” 语句在执行任何延迟函数之前设置结果参数。

实现限制：如果返回位置的作用域中存在与结果参数同名的不同实体（常量、类型或变量），编译器可能不允许 “`return`” 语句中的空表达式列表。

```go
func f(n int) (res int, err error) {
	if _, err := f(n-1); err != nil {
		return  // invalid return statement: err is shadowed
	}
	return
}
```

>---
#### Break 语句

“`break`” 语句终止同一函数中最内层的 “`for`”、“`switch`” 或 “`select`” 语句的执行。

```ANTLR
BreakStmt = "break" [ Label ] 
```

如果有标签，它必须是封闭的 “`for`”、“`switch`” 或 “`select`” 语句的标签，并且是执行终止的那个。

```go
OuterLoop:
	for i = 0; i < n; i++ {
		for j = 0; j < m; j++ {
			switch a[i][j] {
			case nil:
				state = Error
				break OuterLoop
			case item:
				state = Found
				break OuterLoop
			}
		}
	}
```

>---
#### Continue 语句

“`continue`” 语句通过将控制推进到循环块的末尾来开始最里面的封闭 “`for`” 循环的下一次迭代。“`for`” 循环必须在同一个函数中。

```ANTLR
ContinueStmt = "continue" [ Label ] 
```

如果有标签，它必须是一个封闭的 “`for`” 语句的标签，并且是执行前进的那个。

```go
RowLoop:
	for y, row := range rows {
		for x, data := range row {
			if data == endOfRow {
				continue RowLoop
			}
			row[x] = data + bias(x, y)
		}
	}
```

>---
#### Goto 语句

“`goto`” 语句将控制转移到同一函数中具有相应标签的语句。

```ANTLR
GotoStmt = "goto" Label 
```
```go
goto Error
```

执行 “`goto`” 语句时，不能使任何在执行 `goto` 时不在作用域中的变量进入作用域。例如：

```go
	goto L  // BAD
	v := 3	// 跳过创建
L:
```

块外的 “`goto`” 语句不能跳转到该块内的标签。例如：

```go
if n%2 == 1 {
	goto L1
}
for n > 0 {
	f()
	n--
L1:
	f()
	n--
}
```

>---
#### Defer 延迟语句

“`defer`” 语句调用一个函数，该函数的执行被推迟到包围函数返回的时刻，或者是函数执行了一个 `return` 语句而到达了函数体的末尾，或者因为对应的 *goroutine* 发生异常。

```go
DeferStmt = "defer" Expression 
```

表达式必须是函数或方法调用；不能用括号括起来。内置函数的调用与表达式语句一样受到限制。

每次执行 “`defer`” 语句时，调用的函数值和参数都会照常计算并重新保存，但实际的函数不会被调用。相反，延迟函数在包围函数返回之前立即被调用，与它们延迟的顺序相反。也就是说，如果包围函数通过显式 `return` 语句返回，则延迟函数将在该 `return` 语句设置任何结果参数之后，但在函数返回到其调用方之前执行。如果一个延迟的函数值计算为 `nil`，则在调用函数时执行会发生异常，而不是在执行 “`defer`” 语句时。

例如，如果延迟函数是函数文本，并且包围函数具有在文本范围内的命名结果参数，则延迟函数可以在返回结果参数之前访问和修改结果参数。如果延迟函数有任何返回值，则在函数完成时将其丢弃。

```go
lock(l)
defer unlock(l)  // unlocking happens before surrounding function returns

// prints 3 2 1 0 before surrounding function returns
for i := 0; i <= 3; i++ {
	defer fmt.Print(i)
}

// f returns 42
func f() (result int) {
	defer func() {
		// result is accessed after it was set to 6 by the return statement
		result *= 7
	}()
	return 6
}
```

---