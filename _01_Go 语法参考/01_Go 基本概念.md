## Go 基本概念

---

```go
package main
import . "fmt"
func main() {
   Println("Hello, World!")
}
```

参考链接：[golang.google.cn/ref/spec](https://golang.google.cn/ref/spec)

---
### Go 语言结构

#### Package

Go 程序是通过将包链接在一起来构建的。一个包由一个或多个源文件构成的，这些源文件共同声明了属于该包的常量、类型、变量和函数，并且可以在同一个包的所有文件中访问。这些元素可以导出并在另一个包中使用。

<br>

##### 源文件组织

每个源文件都包含一个 `package` 子句，用于定义它所属的包，后面是一组可能为空的导入声明，用于声明它希望使用的内容的包，后面是一组可能为空的函数、类型、变量和常量声明。

```ANTLR
SourceFile  = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } 
```

<br>

##### Package 声明 

`package` 子句开始于每个源文件，并定义该文件所属的包。

```ANTLR
PackageClause  = "package" PackageName 
PackageName    = identifier 
```
```go
package myPack
```

一组共享相同 *PackageName* 的文件构成了包的实现。**实现可能要求一个包的所有源文件都位于同一个目录中**。

<br>

##### Import Package 

*ImportDecl* 声明了包含该声明的源文件依赖于导入包的功能，并允许访问该包的导出标识符。导入命名了一个用于访问的标识符（*PackageName*）和一个指定要导入的包的 *ImportPath*。

```ANTLR
ImportDecl       = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) 
ImportSpec       = [ "." | PackageName ] ImportPath 
ImportPath       = string_lit 
```

*PackageName* 用于限定标识符中，以访问导入源文件中的包的导出标识符。它在文件块中声明。*如果省略PackageName*，则默认为导入包的 *package* 子句中指定的标识符。如果出现了一个明确的句点（ `.` ）而不是名称，则在该包的包块中声明的所有包的导出标识符将在导入源文件的文件块中声明，并且必须在没有限定符的情况下访问。

*ImportPath* 的解释依赖于实现，但它通常是已编译包的完整文件名的子字符串，并且可能与已安装包的存储库相关。

实现限制：编译器可以将 *ImportPath* 限制为非空字符串，仅使用属于 Unicode 的 L、M、N、P 和 S 常规类别的字符（不带空格的图形字符），也可以排除字符 `` !"#$%&'()*,:;<=>?[\]^`{|} `` 和 Unicode 替换字符 U+FFFD。

考虑一个包含 `package` 子句 `package math` 的编译包，它导出函数 `Sin`，并将编译包安装在由 `"lib/math"` 标识的文件中。下面说明了在各种类型的导入声明之后，如何在导入包的文件中访问 `Sin`。

```go
Import declaration          Local name of Sin

import   "lib/math"         math.Sin
import m "lib/math"         m.Sin
import . "lib/math"         Sin
import _ "lib/math"			匿名导入
```

*ImportDecl* 声明了导入包和导入包之间的依赖关系。包直接或间接导入自身，或直接导入包而不引用其导出的任何标识符都是非法的。要导入一个软件包只为了它的副作用（初始化），请使用空白标识符作为显式的软件包名称：

```go
import _ "lib/math"
// 多包导入
import (
    "fmt"
    . "math"
    l "log"    
)
```

对于匿名导入的包，一般用于仅在包初始化期间调用其 `init` 函数（如果有的话）。

<br>

##### Block

块是一个可能为空的声明和语句序列，位于匹配的大括号内。

```ANTLR
Block = "{" StatementList "}" 
StatementList = { Statement ";" } 
```

除了源代码中的显式块之外，还有隐式块：
- *universe* 块包含所有 Go 源代码文本。
- 每个包都有一个 *package* 块，包含该包的所有 Go 源代码文本。
- 每个文件都有一个 *file* 块，其中包含该文件中的所有 Go 源代码文本。
- 每个 “`if`”、“`for`” 和 “`switch`” 语句都被认为是在它自己的隐式块中。
- “`switch`” 或 “`select`” 语句中的每个子句都充当一个隐式块。

<br>

##### 示例封装

下面是一个完整的 Go 语言包，它实现了一个并发的质数筛选。

```go
package main

import "fmt"

// Send the sequence 2, 3, 4, … to channel 'ch'.
func generate(ch chan<- int) {
	for i := 2; ; i++ {
		ch <- i  // Send 'i' to channel 'ch'.
	}
}
// Copy the values from channel 'src' to channel 'dst',
// removing those divisible by 'prime'.
func filter(src <-chan int, dst chan<- int, prime int) {
	for i := range src {  // Loop over values received from 'src'.
		if i%prime != 0 {
			dst <- i  // Send 'i' to channel 'dst'.
		}
	}
}
// The prime sieve: Daisy-chain filter processes together.
func sieve() {
	ch := make(chan int)  // Create a new channel.
	go generate(ch)       // Start generate() as a subprocess.
	for {
		prime := <-ch
		fmt.Print(prime, "\n")
		ch1 := make(chan int)
		go filter(ch, ch1, prime)
		ch = ch1
	}
}
func main() {
	sieve()
}
```

---
