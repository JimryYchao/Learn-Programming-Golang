## Go 程序初始化和执行

---
### 零值初始化

当为变量分配存储时，无论是通过声明或调用 `new`，还是当创建新值时，无论是通过复合文字还是调用 `make`，并且没有提供显式初始化，变量或值都被赋予默认值。这样的变量或值的每个元素都被设置为其类型的零值：
- `false` 用于布尔类型 
- `0` 用于数值类型
- `""` 用于字符串
- `nil` 用于指针，函数，接口，切片，通道和映射。
 
这种初始化是递归完成的，例如，如果没有指定值，结构数组的每个元素的字段都将被置零。

这两个简单的声明是等价的：

```go
var i int
var i int = 0
```

例如结构体：

```go
type T struct { i int; f float64; next *T }
t := new(T)
// var t T   // 等效

// 以下成立
t.i == 0
t.f == 0.0
t.next == nil
```

---
### 包初始化

在包中，包级变量初始化逐步进行，每一步选择声明顺序中最早的变量，该变量与未初始化的变量没有依赖关系。

更确切地说，如果包级变量尚未初始化，并且没有初始化表达式或其初始化表达式与未初始化的变量没有依赖关系，则认为该变量已准备好初始化。初始化是通过重复初始化下一个包级变量来进行，该变量在声明顺序中最早，并准备好初始化，直到没有变量准备进行初始化。

如果在此过程结束时仍有任何变量未初始化，则这些变量是一个或多个初始化周期的一部分，并且程序无效。

由右侧的单个（多值）表达式初始化的变量声明左侧的多个变量一起初始化：如果左侧的任何变量被初始化，则所有这些变量都在同一步骤中初始化。

```go
var x = a
var a, b = f() // a and b are initialized together, before x is initialized
```

为了初始化包，空白变量（`_`）在声明中被视为任何其他变量。

在多个文件中声明的变量的声明顺序取决于文件提交给编译器的顺序：在第一个文件中声明的变量在第二个文件中声明的任何变量之前声明，依此类推。为了确保可重复的初始化行为，建议构建系统将属于同一个包的多个文件按照词法文件名顺序提交给编译器。

依赖性分析不依赖于变量的实际值，只依赖于源代码中对它们的词法引用，并进行传递性分析。例如，如果变量 `x` 的初始化表达式引用的函数体引用变量 `y`，则 `x` 依赖于 `y`。具体而言：
- 对变量或函数的引用是表示该变量或函数的标识符。
- 对方法 `m` 的引用是形式为 `t.m` 的方法值或方法表达式，其中 `t` 的（静态）类型不是接口类型，并且方法 `m` 在 `t` 的方法集中。是否调用结果函数值 `t.m` 并不重要。
- 如果 `x` 的初始化表达式或主体（用于函数和方法）包含对 `y` 或依赖于 `y` 的函数或方法的引用，则变量、函数或方法 `x` 依赖于变量 `y`。

例如，给定声明：

```go
var (
	a = c + b  // == 9
	b = f()    // == 4
	c = f()    // == 5
	d = 3      // == 5 after initialization has finished
)
func f() int {
	d++
	return d
}
```

初始化顺序为 `d`、`b`、`c`、`a`。初始化表达式中子表达式的顺序是无关紧要的：在本例中，`a = c + b` 和 `a = b + c` 的初始化顺序相同。

依赖性分析是针对每个包执行的；只考虑引用当前包中声明的变量、函数和（非接口）方法的引用。如果变量之间存在其他隐藏的数据依赖关系，则未指定这些变量之间的初始化顺序。

例如，给定声明：

```go
var x = I(T{}).ab()   // x has an undetected, hidden dependency on a and b
var _ = sideEffect()  // unrelated to x, a, or b
var a = b
var b = 42

type I interface      { ab() []int }
type T struct{}
func (T) ab() []int   { return []int{a, b} }
```

变量 `a` 将在 `b` 之后被初始化，但是 `x` 是在 `b` 之前、在 `b` 和 `a` 之间、还是在 `a` 之后被初始化，因此也没有指定调用 `sideEffect()` 的时刻（在初始化 `x` 之前或之后）。

全局变量也可以在名为 `init` 的函数初始化，它没有参数和结果参数。

>---
#### init 函数

每个源文件都可以定义自己的无参无返回的 `init` 函数来设置所需的任何状态。

```go
func init() { … }
```

每个包可以定义多个这样的函数，即使在单个源文件中也是如此（实际上，每个文件可以有多个 init 函数）。`init` 在包中的所有变量都对其初始化设定项求值之后被调用，这些初始化设定项只有在所有导入的包都被初始化之后才会求值。

在包块中，`init` 标识符只能用于声明 `init` 函数，但标识符本身没有声明。因此，`init` 函数不能从程序中的任何地方引用。

整个包的初始化首先通过将初始化设定项分配给所有全局变量，然后按照它们在源代码中出现的顺序调用所有 `init` 函数，可能是在多个文件中。最后执行 `main` 包的入口函数 `main()`。

```go
var V int = Init(10)

func main() {
	println("Enter main")
}
func init() { fmt.Println("Enter init A") }
func init() { fmt.Println("Enter init A") }
func Init[T any](t T) (rt T) {
	rt = t
	fmt.Println("Init >>> ", rt)
	return
}
/*
	Init >>>  10
	Enter init A
	Enter init A
	Enter main
*/
```

---
### 程序初始化

一个完整程序的包是逐步初始化的，每次初始化一个包。如果一个包有导入，导入的包在初始化包本身之前被初始化。如果多个包导入一个包，则导入的包将仅初始化一次。通过构造导入包，可以保证不存在循环的初始化依赖。更准确地说：

给定按导入路径排序的所有包的列表，在每一步中，列表中所有导入包（如果有的话）已经初始化的第一个未初始化的包被初始化。重复此步骤，直到所有包都被初始化。

包初始化 — 变量初始化和 `init` 函数的调用 — 在单个 *goroutine* 中依次进行，每次一个包。`init` 函数可以启动其他的 *goroutine*，这些 *goroutine* 可以与初始化代码并发运行。然而，初始化总是对 `init` 函数进行排序：在前一个函数返回之前，它不会调用下一个函数。

`init` 函数的一个常见用途是在正在执行开始之前验证或修复程序状态的正确性。

```go
func init() {
    if user == "" {
        log.Fatal("$USER not set")
    }
    if home == "" {
        home = "/home/" + user
    }
    if gopath == "" {
        gopath = home + "/go"
    }
    // gopath may be overridden by --gopath flag on command line.
    flag.StringVar(&gopath, "gopath", gopath, "override default GOPATH")
}
```

---
### 程序执行

一个完整的程序是通过将一个未导入的包（称为 `package main`）与它导入的所有包递归地链接起来创建的。主包必须有包名 `main`，并声明一个不带参数也不返回值的函数 `main`。

```go
package main
func main(){
	// ...
}
```

程序执行首先开始初始化程序，然后调用程序包 `main` 中的函数 `main`。当函数调用返回时，程序退出。它不会等待其他（非 `main`）*goroutine* 完成。

---