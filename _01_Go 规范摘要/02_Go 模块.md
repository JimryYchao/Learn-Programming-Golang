## Go 模块

---
### 模块概述

模块是 Go 管理依赖关系的方式。模块是一同发布、版本控制和分发的包的集合。在 go.mod 文件中声明和标识模块路径，并包含有关其他模块依赖项的信息。模块根目录是包含 go.mod 文件的目录，`main` 模块是包含调用 go 命令的目录的模块。

模块中的每个包都是同一目录中编译在一起的源文件的集合。包路径是依据根模块目录的相对路径，例如，模块 "golang.org/x/net" 在目录 "html" 中包含一个包，这个包的路径是 "golang.org/x/net/html"。

>---
#### 模块路径

模块路径是模块的规范名称，在模块的 go.mod 文件中使用 `module` 指令声明。模块的路径是模块中包路径的前缀。

```go.mod
module mymodule
```

模块路径由存储库根路径、存储库中的目录（通常为空）和主版本后缀（仅适用于主版本 2 或更高版本）组成。
- 存储库的根目录是模块路径的一部分，大多数模块在其仓库的根目录中定义。
- 若模块不在根目录中定义，则模块名是模块路径中命名目录的一部分，不包括主版本后缀。
- 如果模块是以主版本 2 或更高版本发布的，则模块路径必须以主版本后缀（如 "/v2" ）结束。

路径 "example" 和 "test" 是为用户保留的。

>---
#### 版本控制

版本标识模块的不可变快照，可以是发布版或预发布。[版本语义](https://semver.org/) `major.minor.patch` 解释为：
- major：主版本号，重大修改，存在不兼容的 API。主版本号为零（0.y.z）的软件表示处于开发初始阶段。
- minor：此版本号，功能性新增，API 向下兼容。
- patch：修订号，向下兼容的问题修正。

先行版本号可选的标注在修订号之后，表示这个版本并非稳定且可能无法满足预期的兼容性需求。例如 "1.0.0-alpha"、"1.0.0-alpha.1"、"1.0.0-0.3.7"。

版本编译信息可选的标注在修订号或先行版本号之后。例如 "1.0.0-alpha+001"、"1.0.0+20130313144700"、"1.0.0-beta+exp.sha.5114f85"。

"vX.Y.Z-pre" 后缀表示预发布版本，在相应的发布版本之前排序。例如，"v1.2.3-pre" 在 "v1.2.3" 之前。

>---
#### 解析模块路径

当 go 使用包路径加载包时，需要确定由那个模块提供该包。go 首先在构建列表中搜索路径是包路径前缀的模块。例如，如果导入了包 "`example.com/a/b`"，而模块 "`example.com/a`" 在构建列表中，则 go 命令将检查 "`example.com/a`" 是否包含目录 "b" 中的包。

`-mod=mod` 标志指示 go 命令尝试查找提供缺失包的新模块并更新 go.mod 和 go.sum。 `go get` 和 `go mod tidy` 命令自动执行此操作。

当 go 命令查找一个新模块的包路径时，它会检查 `GOPROXY` 环境变量，并尝试请求每个模块路径提供的包的最新版本。


>---
### 文件 go.mod

模块由其根目录中名为 go.mod 的 UTF-8 编码文本文件定义。`go get` 命令可以升级或降级特定的依赖项。`go mod edit` 命令可以执行低级编辑。

go.mod 文件中的大多数标识符和字符串都是模块路径或版本。

```go.mod
module example.com/my/thing   

go 1.12             

require example.com/other/thing v1.0.2
require example.com/new/thing/v2 v2.3.4
exclude example.com/old/thing v1.2.3
replace example.com/bad/thing v1.4.5 => example.com/good/thing v1.4.5
retract [v1.9.0, v1.9.5]

// 或
require (
    example.com/new/thing/v2 v2.3.4
    example.com/old/thing v1.2.3
)
```

>--- 
#### module 指令

`module` 指令声明主模块的路径，一个 go.mod 有且只有一个 `module` 指令。

```go.mod
module example.com/mod
```

可以在 go.mod 段落之前包含字符串 `Deprecated` 标记模块已弃用。

```go.mod
// Deprecated: use example.com/mod/v2 instead.
module example.com/mod
```

`go list -m -u` 检查构建列表中所有弃用模块的信息。`go get` 检查构建命令行上命名的包所需的弃用模块。

>---
#### go 指令

`go` 指令表示一个模块是假设一个给定版本的 Go 语言。`go` 指令设置了使用此模块所需的 Go 语言的最低版本。自 Go 1.21 起，这是一个强制性的要求：Go 工具链拒绝使用声明较新 Go 版本的模块。

```go.mod
module myModule

go 1.22.2
```

如果缺少 go 指令，则假定为 go 1.16。`go` 行必须声明一个大于或等于 `require` 语句中列出的每个模块所声明的 go 版本的版本。

>---
#### toolchain 指令

`toolchain`  指令声明了一个建议的用于模块的 Go 工具链，工具链版本不能小于 `go` 指令的版本声明。

Go 工具链的选择取决于 `GOTOOLCHAIN` 环境设置以及主模块的 go.mod 文件或当前工作区的 go.work 文件中的 `go` 和 `toolchain` 行。

```go.mod
module myModule

go 1.22.1
toolchain go1.22.2
```

`go` 和 `toolchain` 行可以被认为是指定模块对 Go 工具链本身的依赖的版本要求。`go get` 命令管理 Go 工具链依赖，例如 `go get go@latest` 要求使用最新发布的 Go 工具链以更新模块。

GOTOOLCHAIN 环境设置可以强制执行特定的 Go 版本，覆盖 `go` 和 `toolchain` 行。默认为 `auto`。

```go.mod
GOTOOLCHAIN=go1.21rc3
```

`GOTOOLCHAIN=go1.21.3+auto` 指示 Go 命令开始其决策，默认使用 "Go 1.21.3"，但如果由 `go` 和 `toolchain` 行指示，则仍然使用较新的工具链。`GOTOOLCHAIN` 设置可以用 `go env -w` 更改。

```powershell
$ go env -w GOTOOLCHAIN=go1.21.3+auto
```

>---
#### require 指令

`require` 指令声明了给定模块依赖项的最低要求版本。Go 命令加载该版本的 go.mod 文件，并合并该文件中的要求。

一旦加载了所有的需求，Go 命令使用最小版本选择（MVS）来解析它们，以生成构建列表。

```go.mod
require golang.org/x/net v1.2.3

require (
    golang.org/x/crypto v1.4.5 // indirect
    golang.org/x/text v1.6.7
)
```

Go 命令会自动为某些需求添加 `// indirect` 注释，表示主模块中的任何包都不会直接导入所需模块中的任何包。

>---

#### exclude 指令

`exclude` 指令防止模块版本被 Go 命令加载。从 Go 1.16 开始，如果任何 go.mod 文件中的 `require` 指令引用的版本被主模块的 go.mod 文件中的 `exclude` 指令排除，则该要求将被忽略。这可能会导致像 `go get` 和 `go mod tidy` 这样的命令将更高版本的新要求添加到 go.mod ，并在适当的情况下添加 `// indirect` 注释。

`exclude` 指令只适用于主模块的 go.mod 文件，在其他模块中被忽略。

```go.mod
exclude golang.org/x/net v1.2.3

exclude (
    golang.org/x/crypto v1.4.5
    golang.org/x/text v1.6.7
)
```

>---
#### replace 指令

`replace` 指令将模块的特定版本或所有版本的内容替换（`=>`）为其他地方的内容。可以使用另一个模块路径和版本或特定于平台的文件路径来指定替换。

如果箭头右侧的路径是绝对路径或相对路径（以 `./` 或 `../` 开头），则将其解释为替换模块根目录的本地文件路径，其中必须包含 go.mod 文件。在这种情况下，必须省略替换版本。

`replace` 指令只适用于主模块的 go.mod 文件，在其他模块中被忽略。如果有多个主模块，则所有主模块的 go.mod 文件均适用。不允许在主模块中重写 `replace` 指令，并且必须在 go.work 文件中的替换中删除或重写。

```go.mod
replace golang.org/x/net v1.2.3 => example.com/fork/net v1.4.5

replace (
    golang.org/x/net v1.2.3 => example.com/fork/net v1.4.5
    golang.org/x/net => example.com/fork/net v1.4.5
    golang.org/x/net v1.2.3 => ./fork/net
    golang.org/x/net => ./fork/net
)
```

>---
#### retract 指令

`retract` 指令表示不应该依赖于由 go.mod 定义的模块的版本或版本范围。当一个版本过早发布或在发布后发现严重问题时，`retract` 指令非常有用。在版本控制存储库和模块代理中，存储库版本应该保持可用，以确保依赖于它们的生成不会被破坏。

当模块版本被撤回时，用户不会使用 `go get`、`go mod tidy` 或其他命令自动升级到该版本。依赖于撤回版本的构建应该继续工作，但当用户使用 `go list -m -u` 检查更新或使用 `go get` 更新相关模块时，他们将收到撤回通知。

要撤回一个版本，模块作者应该在 go.mod 中添加一个 `retract` 指令，然后发布一个包含该指令的新版本。`@latest` 版本查询应解析为新版本。Go 命令从 `go list -m -retracted $modpath@latest` 所示的版本加载并应用撤回。

```go.mod
retract (
    v1.0.0 // Published accidentally.
    v1.0.1 // Contains retractions only.
)
```

作为示例，模块 `example.com/m` 的作者意外发布版本 v1.0.0 的情况。为了防止用户升级到 v1.0.0 ，作者可以向 go.mod 添加两个 `retract` 指令，然后用收回标记 v1.0.1。

当用户运行 `go get example.com/m@latest` 时，Go 命令从 v1.0.1 读取撤回，v1.0.1 现在是最高版本。v1.0.0 和 v1.0.1 都被收回，所以 Go 命令将升级（或降级）到下一个最高版本，可能是 v0.9.5。

`retract` 指令可以使用单个版本或使用具有上限和下限的封闭版本间隔来编写。

```go.mod
retract v1.0.0
retract [v1.0.0, v1.9.9]
retract (
    v1.0.0
    [v1.0.0-0, v1.9.9]   // 包含伪版本
)
```

>---
#### 自动更新

go.mod 缺少信息或不能准确反映实际情况时，使用 `go get` 和 `go mod tidy` 命令来修复大多数问题。`-mod=mod` 标志可以与大多数模块感知命令（`go build`、`go test` 等）一起使用，以指示 Go 命令自动修复 go.mod 和 go.sum 中的问题。

```go.mod
module example.com/M

go 1.16

require (
    example.com/A v1
    example.com/B v1.0.0
    example.com/C v1.0.0
    example.com/D v1.2.3
    example.com/E dev
)

exclude example.com/D v1.2.3dw
```

由 `-mod=mod` 触发的更新将非规范版本标识符重写为规范形式：
- `example.com/A` 的 v1 变为 v1.0.0。
- `example.com/E` 的 dev 变为 dev 分支上最新提交的伪版本。
- 更新排除了 `example.com/D v1.2.3`，以使用 `example.com/D` 的下一个可用版本。

因为模块图定义了 `import` 语句的含义，所以任何加载包的命令也使用 go.mod ，因此 `go build`，`go get`，`go install`，`go list`，`go test`，`go mod tidy` 都可以用来更新它。

>---
### 工作区

工作区是磁盘上的模块集合，在运行最小版本选择（MVS）时用作主模块，在 go.work 文件中声明，该文件指定工作区中每个模块的模块目录的相对路径。当不存在 go.work 文件时，工作区由包含当前目录的单个模块组成。

大多数与模块一起工作的 Go 子命令都对当前工作区确定的模块集进行操作。`go mod init`、`go mod why`、`go mod edit`、`go mod tidy`、`go mod vendor` 和 `go get` 始终在单个主模块上运行。

命令通过首先检查 `GOWORK` 环境变量来确定它是否在工作区上下文中。如果 `GOWORK` 设置为 `off`，则命令将在单模块上下文中。如果它为空或未提供，该命令将搜索当前工作目录，然后是后续的父目录，以查找文件 go.work。如果找到了文件，则命令将在它定义的工作区中操作；否则，工作区将仅包括包含工作目录的模块。如果 `GOWORK` 命名了一个以 `.work` 结尾的现有文件的路径，工作区模式将被启用。任何其他值都是错误的。可以使用 `go env GOWORK` 命令来确定 Go 命令正在使用哪个 go.work 文件。如果 Go 命令未处于工作区模式，则 `go env GOWORK` 将为空。

>---
#### go.work 文件

```go.work
go 1.18

use (
    ./my/first/thing
    ./my/second/thing
) 

replace example.com/bad/thing v1.4.5 => example.com/good/thing v1.4.5
```

Go 命令提供了几个子命令来操作 go.work 文件。`go work init` 创建新的 go.work 文件。`go work use` 将模块目录添加到 go.work 文件。`go work edit` 执行低级编辑。Go程序可以使用 `golang.org/x/mod/modfile` 包以编程方式进行相同的更改。

Go 命令将维护一个 `go.work.sum` 文件，该文件跟踪工作区使用的散列，这些散列不在集体工作区模块的 go.sum 文件中。

>---
#### go 指令

`go` 指令指示 go.work 文件要使用的 Go 工具链版本。一个 go.work 文件最多只能包含一个 `go` 指令。

```go.work
go 1.18
```

>---
#### toolchain 指令

`toolchain` 指令声明了一个建议在工作区中使用的 Go 工具链。它仅在默认工具链比建议的工具链旧时有效。

```go.work
toolchain go1.21.0
```

>---
#### use 指令

`use` 将磁盘上的模块添加到工作区中的主模块集。它的参数是包含模块 go.mod 文件的目录的相对路径。`use` 指令不添加包含在其参数目录的子目录中的模块。这些模块可以通过包含其 go.mod 文件的目录添加到单独的 `use` 指令中。

```go.work
use ./mymod  // example.com/mymod

use (
    ../othermod
    ./subdir/thirdmod
)
```

>---
#### replace 指令

go.work 文件中的 `replace` 指令用其他地方找到的内容替换模块的特定版本或模块的所有版本的内容。 go.work 中的一个重复替换覆盖了 go.mod 文件中特定于版本的 `replace`。

go.work 文件中的 `replace` 指令覆盖工作区模块中相同模块或模块版本的任何替换。

```go.work
replace golang.org/x/net v1.2.3 => example.com/fork/net v1.4.5

replace (
    golang.org/x/net v1.2.3 => example.com/fork/net v1.4.5
    golang.org/x/net => example.com/fork/net v1.4.5
    golang.org/x/net v1.2.3 => ./fork/net
    golang.org/x/net => ./fork/net
)
```

---
### 模块感知命令

大多数 Go 命令可以在模块感知模式或 `GOPATH` 模式下运行。在模块感知模式下，Go 命令使用 go.mod 文件来查找版本依赖项，它通常会从模块缓存中加载包，如果缺少模块则下载模块。在 `GOPATH` 模式下，Go 命令会忽略模块；它会在 `vendor` 和 `GOPATH` 目录中查找依赖项。

从 Go 1.16 开始，模块感知模式默认启用，无论是否存在 go.mod 文件。在较低版本中，在当前目录或任何父目录中存在 go.mod 文件时，模块感知模式被启用。

模块感知模式可以用 `GO111MODULE` 环境变量来控制，该环境变量可以被设置为 `on`、`off` 或 `auto`：
- `on`：Go 命令将忽略 go.mod 文件并以 `GOPATH` 模式运行。
- `off`：即使不存在 go.mod 文件，Go 命令也会以模块感知模式运行。并非所有命令都可以在没有 go.mod 文件的情况下工作。
- `auto`：在当前目录或任何父目录中存在 go.mod 文件时，Go 命令将以模块感知模式运行。

在模块感知模式下，`GOPATH` 不再定义构建期间导入的含义，但它仍然存储下载的依赖项（在 `GOPATH/pkg/mod` 中）和安装的命令（在 `GOPATH/bin` 中，除非设置了 `GOBIN`）。

>---
#### 构建命令

```powershell
$ go build          
$ go fix            
$ go generate
$ go install
$ go list
$ go run
$ go test
$ go vet
```

当在模块感知模式下运行时，这些命令使用 go.mod 文件来解释命令行上列出的或 Go 源文件中编写的导入路径。这些命令接受所有模块命令通用的以下标志：

- `mod` 标志控制是否可以自动更新 go.mod 以及是否使用 vendor 目录。
  - `-mod=mod` 告诉 Go 命令忽略 vendor 目录并自动更新 go.mod ，例如当导入的包不是由任何已知模块提供时。
  - `-mod=readonly` 告诉 Go 命令忽略 vendor 目录，并在需要更新 go.mod 时报告错误。
  - `-mod=vendor` 告诉 Go 命令使用 vendor 目录。在此模式下，Go 命令将不使用网络或模块缓存。
  - 默认情况下，如果 go.mod 中的 Go 版本为 1.14 或更高版本，并且存在 vendor 目录，则 Go 命令的作用就像使用了 `-mod=vendor` 一样。否则， Go 命令就像使用了 `-mod=readonly` 一样。
  - `go get` 拒绝此标志，因为该命令的目的是修改依赖关系，而这仅由 `-mod=mod` 允许。
+ `-modcacherw` 标志指示 Go 命令在模块缓存中创建具有读写权限的新目录，而不是将其设置为只读。当这个标志被一致地使用时（通常通过在环境中设置 `GOFLAGS=-modcacherw` 或通过运行 `go env -w GOFLAGS=-modcacherw`），模块缓存可以用像 `rm -r` 这样的命令删除，而不需要首先更改权限。无论是否使用 `-modcacherw`，`go clean -modcache` 命令都可以用于删除模块缓存。

- `-modfile=file.mod` 标志指示 Go 命令读取（并可能写入）模块根目录中的替代文件，而不是 go.mod。文件名必须以 `.mod` 结尾。一个名为 go.mod 的文件必须仍然存在，以确定模块根目录，但它不会被访问。当指定了 `-modfile` 时，也会使用一个备用的 go.sum 文件：它的路径是通过修剪 .mod 扩展名并附加 .sum 从 `-modfile` 标志派生的。

>---
#### Vendoring

当使用模块时，Go 命令通常通过将模块从其源下载到模块缓存中，然后从这些下载的副本加载包来满足依赖性。Vendoring 可以用于允许与旧版本的 Go 进行互操作，或者确保用于构建的所有文件都存储在单个文件树中。

`go mod vendor` 命令在主模块的根目录中构造一个名为 vendor 的目录，其中包含在主模块中构建和测试包所需的所有包的副本。不包括仅由主模块之外的包的测试导入的包。与 `go mod tidy` 和其他模块命令一样，在构造 vendor 目录时，不考虑除 ignore 之外的构建约束。

`go mod vendor` 还创建了文件 "vendor/modules.txt"，其中包含一个供应的软件包列表以及它们所复制的模块版本。当启用验证时，此清单用作模块版本信息的来源，如 `go list -m` 和 `go version -m` 所报告的。当 Go 命令读取 "vendor/modules.txt" 时，它检查模块版本是否与 go.mod 一致。如果在生成 "vendor/modules.txt" 后 go.mod 发生了更改，则 Go 命令将报告错误。应再次运行 `go mod vendor` 以更新 vendor 目录。

如果主模块的根目录中存在 vendor 目录，如果主模块的 go.mod 文件中的 Go 版本为 1.14 或更高版本，则将自动使用该目录。要显式启用验证，则调用带有标记 `-mod=vendor` 的 Go 命令。要禁用验证，请使用标记 `-mod=readonly` 或 `-mod=mod`。

当启用缓存时，像 `go build` 和 `go test` 这样的构建命令从 vendor 目录加载包，而不是访问网络或本地模块缓存。`go list -m` 命令仅打印有关 go.mod 中列出的模块的信息。`go mod` 命令（如 `go mod download` 和 `go mod tidy`）在启用缓存时不会以不同的方式工作，仍然会下载模块并访问模块缓存。`go get` 在启用验证时也不会有不同的工作方式。

与 `GOPATH` 模式下的验证不同，Go 命令忽略主模块根目录以外的 vendor 目录。此外，由于其他模块中的 vendor 目录未被使用，因此在构建模块 zip 文件时，Go 命令不包括 vendor 目录。

>---
#### go get

`go get` 命令更新主模块的 go.mod 文件中的模块依赖项，然后构建并安装命令行上列出的软件包。

```shell
go get [-d] [-t] [-u] [build flags] [packages]
```
```shell
# Upgrade a specific module.
$ go get golang.org/x/net

# Upgrade modules that provide packages imported by packages in the main module.
$ go get -u ./...

# Upgrade or downgrade to a specific version of a module.
$ go get golang.org/x/text@v0.3.2

# Update to the commit on the module's master branch.
$ go get golang.org/x/text@master

# Remove a dependency on a module and downgrade modules that require it
# to versions that don't require it.
$ go get golang.org/x/text@none

# Upgrade the minimum required Go version for the main module.
$ go get go

# Upgrade the suggested Go toolchain, leaving the minimum Go version alone.
$ go get toolchain

# Upgrade to the latest patch release of the suggested Go toolchain.
$ go get toolchain@patch
```

